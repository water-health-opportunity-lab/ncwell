---
title: "Exploratory Data Analysis (Vulnerability Module Part I)"
format: html
toc: true
editor: visual
code-fold: true
self-contained: true
---

## 1. Highlight and a Summary

The below is a highlight for this exploratory data analysis of vulnerability module.

1.  **There are a lot of missing values for Tile Drainage.**
2.  It is more complicated to deal with the outliers in this dataset. I have tried transformation and top coding or bottom coding to deal with them. However, even after this, there are still some outliers. Nevertheless, they look more well-behaved after such treatment.
3.  There exist serious multicollinearity in this dataset. Under a rule of thumb for VIF to be 10, we have to remove some of the variables in the group Soil properties, Soil geochemistry, and Landscape. See details in Section 3.

The sample size of this dataset is 129169 and it has 89 variables.

```{r}
# load packages
require('sf')
require('ggplot2')

# read data
data <- st_read('nc_grid_vulnerability_full.gpkg')

# remove duplicated observations
data <- data[!duplicated(data$geom), ]

# total sample size
(n <- nrow(data))

# dimension
(p <- ncol(data) - 3)

# colnames
colnames(data)
```

Next, we look into the variables in different groups.

## 2. Analysis for different variables

Next, we present the exploratory data analysis for different variables. We check missing percentage, mean, standard deviation (SD), median, and interquantile range (IQR) of the variables. Moreover, the histograms and boxplots of the variables are also presented. The proportions of outliers are also provided.

### **2.1 Groundwater**

First, the descriptive statistics of the variables in groundwater group are presented below. We observe a lot of variability for Transmissivity.

```{r}
# check interquantile range
iqr <- function(x) paste0(round(quantile(na.omit(x), .25), 2), '-', 
                          round(quantile(na.omit(x), .75), 2))

# function for summary statistics
summ <- function(x, names) {
  p <- ncol(x)
  n <- nrow(x)
  tab <- data.frame()
  for (j in 1:p) {
    x.j <- x[, j]
    if (is.character(x.j) == TRUE) {
      info <- c(round(length(which(is.na(x.j) == TRUE)) / n * 100, 2),
              class(x.j),
              NA,
              NA,
              NA,
              NA)
    } else {
    info <- c(round(length(which(is.na(x.j) == TRUE)) / n * 100, 2),
              class(x.j),
              round(mean(x.j, na.rm = TRUE), 2),
              round(sd(x.j, na.rm = TRUE), 2),
              round(median(x.j, na.rm = TRUE), 2),
              iqr(x.j)) 
    }
    tab <- rbind(tab, info)
  }
  tab <- cbind(names, tab)
  colnames(tab) <- c('Name', 'Missing Percentage', 'Class', 'Mean', 
                     'SD', 'Median', 'IQR')
  print(tab)
}

# summary
names1 <- c('Aquifer Rock Type', 'Depth to Water', 'Nitrate, domestic well depths',
            'Nitrate, public well depths', 'Transmissivity', 'Unsat Zone Travel Time',
            'Unsat Zone Water Content')
x.1 <- cbind(data$aq_rocktype, data$dtw, data$no3_dom, data$no3_pub,
             data$trans, data$unsatTT, data$unsatWC)

## record indices (useful for later transformation)
colnames(x.1) <- substr(colnames(x.1), 6, nchar(colnames(x.1)))
index.1 <- sapply(colnames(x.1), function(x) which(x == colnames(data)))

summ(x = x.1, names = names1)
```

The histograms of those variables are presented below. Note that

1.  Aquifer Rock Type is a categorical variable.
2.  The distribution of Depth to Water is right-skewed.
3.  The distribution of Nitrate, domestic well depths is right-skewed.
4.  The distribution of Nitrate, public well depths is right-skewed.
5.  The distribution of Transmissivity is heavily right-skewed.
6.  The distribution of Unsat Zone Travel Time is right-skewed.
7.  The distribution of Unsat Zone Water Content is bell-shaped.

```{r}
par(mfrow = c(1, 3))
hist(data$aq_rocktype, col = 'white', border = 'magenta',
     xlab = '',
     main = names1[1])
hist(data$dtw, col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names1[2])
hist(data$no3_dom, col = 'white', border = 'indianred1',
     xlab = '',
     main = names1[3])
par(mfrow = c(1, 3))
hist(data$no3_pub, col = 'white', border = 'magenta',
     xlab = '',
     main = names1[4])
hist(data$trans, col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names1[5])
hist(data$unsatTT, col = 'white', border = 'indianred1',
     xlab = '',
     main = names1[6])
hist(data$unsatWC, col = 'white', border = 'slateblue',
     xlab = '',
     main = names1[7])
```

The boxplots of those variables (except Aquifer Rock Type) are presented below. As we can see, all except for Unsat Zone Water Content contains a lot of outliers.

```{r}
par(mfrow = c(1, 3))
boxplot(data$dtw, col = 'white', border = 'magenta',
        xlab = names1[2])
boxplot(data$no3_dom, 
        xlab = names1[3],
        col = 'white', border = 'deepskyblue')
boxplot(data$no3_pub, 
        xlab = names1[4],
        col = 'white', border = 'indianred1')
par(mfrow = c(1, 3))
boxplot(data$trans, col = 'white', border = 'magenta',
        xlab = names1[5])
boxplot(data$unsatTT, 
        xlab = names1[6],
        col = 'white', border = 'deepskyblue')
boxplot(data$unsatWC, 
        xlab = names1[7],
        col = 'white', border = 'indianred1')
```

In specific, the percentage of outliers on the right-tail is shown below. They are defined as the observations that have distances greater than 1.5 times IQR from the 75% quantile or distances lower than 1.5 times IQR from the 25% quantile. So, we observe there are a lot of outliers for

1.  Nitrate, domestic well depths
2.  Nitrate, public well depths
3.  Transmissivity

```{r}
# find the percentage of outliers on the right tail
whisker <- function(x) {
  n <- length(x)
  qf <- quantile(x, c(.25, .75), na.rm = TRUE)
  IQR <- qf[2] - qf[1]
  length(which(x > qf[2] + 1.5 * IQR | x < qf[1] - 1.5 * IQR)) / n
}

# percentage of outliers on the right tail
outlier.percent <- apply(x.1[, 2:7], 2, whisker) * 100
names(outlier.percent) <- names1[-1]
print(round(outlier.percent, 2))
```

Next, we check if square root transformation helps. The idea is to cover a desired proportion of data (say, 98%) of normally behaved data under some transformation.

```{r}
oc.check <- function(x, level = .99, method = 'power', degree) {
  x[which(x == Inf)] <- NA
  x <- na.omit(x)
  cv <- qnorm(level)
  if (method == 'log') {
    x <- log(na.omit(x) + 1e-4)
  } else if (method == 'sqrt') {
    x <- sqrt(x)
  } else if (method == 'boxcox') {
    fit <- lm(x ~ 1)
    bc <- boxcox(fit, lambda = seq(2, 10, 0.1))
    best_lambda <- bc$x[which.max(bc$y)]
    x <- (x ^ best_lambda - 1) / best_lambda
  } else if (method == 'power') {
    x <- x ^ (degree)
  } else if (method == 'log10') {
    x <- log10(x + 1e-4)
  }
  n <- length(x)
  length(which(x > mean(x) + cv * sd(x) | x < mean(x) - cv * sd(x))) / n
}

# square root transformation
check <- apply(x.1[, 2:7], 2, function(x) oc.check(x, method = 'sqrt'))
names(check) <- names1[-1]
print(round(check * 100, 2))

# log transformation
check <- apply(x.1[, 2:7], 2, function(x) oc.check(x, method = 'log'))
names(check) <- names1[-1]
print(round(check * 100, 2))

data$dtw <- sqrt(data$dtw)
data$unsatWC <- sqrt(data$unsatWC)
data$unsatTT <- sqrt(data$unsatTT)

data$trans <- log(data$trans)
data$no3_dom <- log(data$no3_dom)
data$no3_pub <- log(data$no3_pub)
```

As we can see,

1.  square root transformation works for Depth to Water, Unsat Zone Travel Time, and Unsat Zone Water Content.
2.  Log transformation works better for Transmissivity, Nitrate, domestic well depths, and Nitrate, public well depths.

Next, we take a look at the spatial distribution of those two variables. For superfund, most of the regions have zero values with a few spots being greater than zero.

```{r}
ggplot(data = data) + geom_sf(aes(color = sqrt(x.1[, 1]))) + 
  theme_bw() + labs(title = paste0(names1[1], ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.1[, 2] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names1[2], ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.1[, 3] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names1[3], ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.1[, 4]))) + 
  theme_bw() + labs(title = paste0(names1[4], ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.1[, 5] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names1[5], ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.1[, 6]))) + 
  theme_bw() + labs(title = paste0(names1[6], ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.1[, 7])) + 
  theme_bw() + labs(title = names1[7]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')

x1.trans <- data.frame(sqrt(x.1[, 1]), log(x.1[, 2] + 1e-4),
                       log(x.1[, 3] + 1e-4), log(x.1[, 4] + 1e-4),
                       log(x.1[, 5] + 1e-4), sqrt(x.1[, 6]), x.1[, 7])

data[, index.1] <- x1.trans
```

### **2.2 Geology**

Note that Bedrock, Lithology, and Surficial geology are categorical. So, we simply summarize the proportion of the categories below. For tile drainage, its summary statistics are provided as well. Note that there are a lot of missing values for tile drainage. So, we will drop this variable.

```{r}
## Bedrock
print('Percentage of categories in Bedrock')
round(table(data$KB) / nrow(data) * 100, 2)
print('Missing percentage of Bedrock')
length(which(is.na(data$KB) == TRUE)) * 100 / nrow(data)

## keep the most common three categories, combine the rest into "others"
KB <- data$KB
top3 <- names(sort(table(KB), decreasing = TRUE)[1:3])
KB[which(KB %in% top3 == FALSE)] <- 'others'
data$KB <- KB

## Lithology
print('Percentage of categories in Lithology')
round(table(data$lith) / nrow(data) * 100, 2)
print('Missing percentage of Lithology')
length(which(is.na(data$lith) == TRUE)) * 100 / nrow(data)

## keep the most common two categories, combine the rest into "others"
lith <- data$lith
top2 <- names(sort(table(lith), decreasing = TRUE)[c(1, 2)])
lith[which(lith %in% top2 == FALSE)] <- 'others'
data$lith <- lith

## Surficial geology
print('Percentage of categories in Surficial geology')
round(table(data$surfgeo) / nrow(data) * 100, 2)
print('Missing percentage of Surficial geology')
length(which(is.na(data$surfgeo) == TRUE)) * 100 / nrow(data)

## keep the most common two categories, combine the rest into "others"
surfgeo <- data$surfgeo
top2 <- names(sort(table(surfgeo), decreasing = TRUE)[c(1, 2)])
surfgeo[which(surfgeo %in% top2 == FALSE)] <- 'others'
data$surfgeo <- surfgeo

# summary
names2 <- c('Bedrock', 'Lithology', 'Surficial geology',
            'Tile Drainage')
x.2 <- data.frame(data$KB, data$lith, data$surfgeo, data$drainage)
summ(x = as.matrix(x.2[, 4]), names = names2[4])
```

Next, we check the histogram and boxplot of tile drainage. As we can observe, Tile Drainage is right-skewed with some outliers on the right tail.

```{r}
par(mfrow = c(1, 2))
hist(data$drainage, col = 'white', border = 'magenta',
     xlab = '',
     main = names2[4])
boxplot(data$drainage, col = 'white', border = 'magenta',
        xlab = names2[4])
```

Next, we find the percentage of outliers on the right-tail. As we can see, we do not observe many outliers. So, there is no need to do transformation.

```{r}
# find the percentage of outliers on the right tail
right.whisker <- function(x) {
  n <- length(x)
  qf <- quantile(x, c(.25, .75), na.rm = TRUE)
  IQR <- qf[2] - qf[1]
  length(which(x > qf[2] + 1.5 * IQR)) / n
}

# percentage of outliers on the right tail
outlier.percent <- right.whisker(data$drainage) * 100 
names(outlier.percent) <- names2[4]
print(round(outlier.percent, 2))
```

Next, we take a look at the spatial distribution of those variables below.

```{r}
# Bedrock
ggplot(data = data) +
  geom_sf(aes(color = KB, fill = KB), size = 0.5) +
  theme_bw() +
  labs(title = names2[1], fill = paste0(names2[1], ' Categories'),
       color = paste0(names2[1], ' Categories')) +
  theme(panel.grid = element_blank())

# Lithology
ggplot(data = data) +
  geom_sf(aes(color = lith, fill = lith), size = 0.5) +
  theme_bw() +
  labs(title = names2[2], fill = paste0(names2[2], ' Categories'),
       color = paste0(names2[2], ' Categories')) +
  theme(panel.grid = element_blank()) + 
  theme(legend.title = element_text(size = 3), 
        legend.text = element_text(size = 3))
# Surficial geology
ggplot(data = data) +
  geom_sf(aes(color = surfgeo, fill = surfgeo), size = 0.5) +
  theme_bw() +
  labs(title = names2[3], fill = paste0(names2[3], ' Categories'),
       color = paste0(names2[3], ' Categories')) +
  theme(panel.grid = element_blank())

ggplot(data = data) + geom_sf(aes(color = drainage)) + 
  theme_bw() + labs(title = "Tile Drainage") + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')

x2.trans <- data$drainage
```

### **2.3 Hydroclimate**

Next, we summarize the variables in the hydroclimate group. Note that the hydrologic unit code is a categorical variable. For the remaining variables, we do not observe many missing values.

```{r}
# distribution of hydrologic unit code
summary(data$HUC_12)

names3 <- c('Base-flow Index', 'Evapotranspiration', 
            'Precipitation', 
            'Quickflow', 'Recharge', 'Stream Density',
            'Temperature', 'Effective Recharge')
x.3 <- data.frame(data$bfi, data$ET, data$ppt, 
                  data$qf, data$rech, data$stm_den, 
                  data$tmean, data$effrech)

## record indices (useful for later transformation)
colnames(x.3) <- substr(colnames(x.3), 6, nchar(colnames(x.3)))
index.3 <- sapply(colnames(x.3), function(x) which(x == colnames(data)))

summ(x = x.3, names = names3)
```

Next, we check the histogram of those variables.

```{r}
par(mfrow = c(1, 3))
hist(x.3[, 1], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[1])
hist(x.3[, 2], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[2])
hist(x.3[, 3], col = 'white', border = 'indianred1',
     xlab = '',
     main = names3[3])
par(mfrow = c(1, 3))
hist(x.3[, 4], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[4])
hist(x.3[, 5], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[5])
hist(x.3[, 6], col = 'white', border = 'indianred1',
     xlab = '',
     main = names3[6])
par(mfrow = c(1, 2))
hist(x.3[, 7], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[7])
hist(x.3[, 8], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[8])
```

As we can observe,

1.  Base-flow index and Evapotranspiration are bell-shaped.
2.  The distributions of Quickflow, Precipitation, Recharge, and Effective Recharge are right-skewed.
3.  The distribution of Temperature is left-skewed.

Next, we check the boxplots of those variables.

```{r}
par(mfrow = c(1, 3))
boxplot(x.3[, 1], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[1])
boxplot(x.3[, 2], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[2])
boxplot(x.3[, 3], col = 'white', border = 'indianred1',
     xlab = '',
     main = names3[3])
par(mfrow = c(1, 3))
boxplot(x.3[, 4], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[4])
boxplot(x.3[, 5], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[5])
boxplot(x.3[, 6], col = 'white', border = 'indianred1',
     xlab = '',
     main = names3[6])
par(mfrow = c(1, 2))
boxplot(x.3[, 7], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[7])
boxplot(x.3[, 8], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[8])
```

According to the boxplots, we see there exist some outliers for

1.  Evapotranspiration on the both right and left tails.
2.  Precipitation on the both right and left tails.
3.  Quickflow on the right tail
4.  Recharge on the right tail
5.  Stream Density on the both right and left tails.
6.  Temperature on the left tail.
7.  Effective Recharge on the right tail.

Last, we check the proportion of outliers as below. As we can observe below, there are many outliers for Precipitation, Quickflow, Recharge, Stream Density, and Temperature.

```{r}
whisker <- function(x) {
  n <- length(x)
  qf <- quantile(x, c(.25, .75), na.rm = TRUE)
  IQR <- qf[2] - qf[1]
  length(which(x > qf[2] + 1.5 * IQR | x < qf[1] - 1.5 * IQR)) / n
}
# percentage of outliers on the right tail
outlier.percent <- apply(x.3, 2, whisker) * 100
names(outlier.percent) <- names3
print(round(outlier.percent, 2))
```

Similarly, we check whether we can apply some transformation to avoid this issue.

```{r}
check <- apply(x.3, 2, function(x) oc.check(x, method = 'sqrt'))
names(check) <- names3
print(round(check * 100, 2))
check <- apply(x.3, 2, function(x) oc.check(x, method = 'log'))
names(check) <- names3
print(round(check * 100, 2))
```

So, some of those transformations do not help. To resolve this, we try if the top coding or bottom coding helps, which replaces the values above $1-\alpha$ quantile of the variable with $1-\alpha$ quantile or those below $\alpha$ quantile of the variable with $\alpha$ quantile. As we can observe below, it slightly helps with $\alpha = 2\%$. Note that

1.  both top coding and bottom coding are applied to Evaportranspiration, Precipitation, and Stream density because they have outliers on both left and right tails.
2.  top coding is applied to recharge and quickflow because it has outliers only on the right tail.
3.  bottom coding is applied to Temperature because it has outliers only on the left tail.

```{r}
coding <- function(x, alpha = 0.02, 
                     tail = c('left', 'right', 'both')) {
  lt <- quantile(x, alpha, na.rm = TRUE)
  rt <- quantile(x, 1 - alpha, na.rm = TRUE)
  
  if (tail == 'left') {
    x[which(x < lt)] <- lt
  } else if (tail == 'right') {
    x[which(x > rt)] <- rt
  } else {
    x[which(x < lt)] <- lt
    x[which(x > rt)] <- rt
  }
  
  return(x)
}
# Evaportranspiration
x3.2.trans <- coding(x.3[, 2], tail = 'both')
oc.check(x3.2.trans, method = 'power', degree = 1) * 100

# precipitation
x3.3.trans <- coding(sqrt(x.3[, 3]), tail = 'both')
oc.check(x3.3.trans, method = 'power', degree = 1) * 100

# quickflow
x3.4.trans <- coding(sqrt(x.3[, 4]), tail = 'right')
oc.check(x3.4.trans, method = 'power', degree = 1) * 100

# recharge
x3.5.trans <- coding(log(x.3[, 5] + 1e-4), tail = 'right')
oc.check(x3.5.trans, method = 'power', degree = 1) * 100

# Stream density
x3.6.trans <- coding(log(x.3[, 6] + 1e-4), tail = 'both')
oc.check(x3.6.trans, method = 'power', degree = 1) * 100

# Temperature
x3.7.trans <- coding(sqrt(x.3[, 7]), tail = 'left')
oc.check(x3.7.trans, method = 'power', degree = 1) * 100
```

So, even after top coding, there are some outliers. It might be better to check their distributions again. As we can observe below, they appear much more well-behaved.

```{r}
x3.trans <- cbind(x.3[, 1], x3.2.trans, x3.3.trans,
                  x3.4.trans, x3.5.trans, x3.6.trans, 
                  x3.7.trans, log(x.3[, 8] + 1e-4))

x.3 <- data.frame(data$bfi, data$ET, data$ppt, 
                  data$qf, data$rech, data$stm_den, 
                  data$tmean, data$effrech)

data$ET <- x3.2.trans
data$ppt <- x3.3.trans
data$qf <- x3.4.trans
data$rech <- x3.5.trans
data$stm_den <- x3.6.trans
data$tmean <- x3.7.trans
data$effrech <- log(data$effrech + 1e-4)

cols <- c('magenta', 'deepskyblue', 'indianred1',
          'slateblue', 'royalblue', 'salmon')
par(mfrow = c(2, 3))
for (i in 2:7) {
  hist(x3.trans[, i], border = cols[i - 1], 
       col = 'white', main = paste0(names3[i]))
}
```

Next, we take a look at the spatial distribution of the transformed variables.

```{r}
ggplot(data = data) + geom_sf(aes(color = x.3[, 1])) + 
  theme_bw() + labs(title = names3[1]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 2])) + 
  theme_bw() + labs(title = names3[2]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 3])) + 
  theme_bw() + labs(title = paste0(names3[3], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 4])) + 
  theme_bw() + labs(title = paste0(names3[4], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 5])) + 
  theme_bw() + labs(title = paste0(names3[5], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 6])) + 
  theme_bw() + labs(title = paste0(names3[6], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 7])) + 
  theme_bw() + labs(title = paste0(names3[7], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 8])) + 
  theme_bw() + labs(title = paste0(names3[8], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
```

### **2.4 Landscape**

The summary statistics of the variables in this group are provided below.

```{r}
### land use (collapse)
landuse <- data$landuse
landuse[which(landuse %in% c("13", "20", "40"))] <- 'cultivated'
landuse[which(landuse %in% c("31", "32"))] <- 'developed'
data$landuse <- as.character(landuse)

# summary
names4 <- c('% Agriculture', '% Croplands', '% Developed',
            '% Emergent Herbaceous Wetlands', '% Forest', '% Forest and Woody Wetlands',
            'Waterbody Buffer', '% Impervious', '% Natural Land Cover', '% Pasture',
            '% Wetlands', 'Average buffer width', 'Land use', 'Land cover')
x.4 <- data.frame(data$PAGT, data$PAGC, data$PDEV, data$PWETL95,
             data$PFOR, data$PFOR90, data$rfor9045, data$PIMPV,
             data$N_INDEX, data$PAGP, data$PWETL, data$Avg_Buff_Width,
             data$landuse, data$landcover)

## record indices (useful for later transformation)
colnames(x.4) <- substr(colnames(x.4), 6, nchar(colnames(x.4)))
index.4 <- sapply(colnames(x.4)[-13], function(x) which(x == colnames(data)))

summ(x = x.4, names = names4)

# summary of the distribution of land use
table(data$landuse)
```

The histograms of those variables are provided below. Note that

1.  The distribution of % Agriculture is right-skewed.
2.  The distribution of % Croplands is right-skewed.
3.  The distribution of % Developed is right-skewed.
4.  The distribution of % Emergent Herbaceous Wetlands is heavily right-skewed.
5.  The distribution of % Forest is not either left-skewed or right-skewed.
6.  The distribution of Forest and Woody Wetlands look bell-shaped.
7.  The distribution of Waterbody Buffer is left-skewed.
8.  The distribution of % Impervious is heavily right-skewed.
9.  The distribution of % Natural Land Cover looks slightly left-skewed.
10. The distribution of % Pasture is right-skewed.
11. The distribution of % Wetlands is right-skewed.
12. The distribution of Average buffer width is highly right-skewed.
13. The distribution of Land use is categorical.
14. The distribution of Land cover looks bell-shaped.

```{r}
cols <- c('magenta', 'deepskyblue', 'indianred1')
par(mfrow = c(1, 3))
for (j in 1:3) {
  hist(x.4[, j], col = 'white', border = cols[j],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 4:6) {
  hist(x.4[, j], col = 'white', border = cols[j - 3],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 7:9) {
  hist(x.4[, j], col = 'white', border = cols[j - 6],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 10:12) {
  hist(x.4[, j], col = 'white', border = cols[j - 9],
       xlab = '',
       main = names4[j])
}

hist(x.4[, 14], col = 'white', border = cols[14 - 12],
       xlab = '',
       main = names4[14])
```

The boxplots of those variables are summarized below. We can observe there are many outliers for % Developed, % Emergent Herbaceous Wetlands, Waterbody Buffer, % Impervious, and Average buffer width.

```{r}
par(mfrow = c(1, 3))
for (j in 1:3) {
  boxplot(x.4[, j], col = 'white', border = cols[j],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 4:6) {
  boxplot(x.4[, j], col = 'white', border = cols[j - 3],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 7:9) {
  boxplot(x.4[, j], col = 'white', border = cols[j - 6],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 10:12) {
  boxplot(x.4[, j], col = 'white', border = cols[j - 9],
       xlab = '',
       main = names4[j])
}

boxplot(x.4[, 14], col = 'white', border = cols[14 - 12],
       xlab = '',
       main = names4[14])
```

Next, we check the percentage of outliers below.

```{r}
# percentage of outliers on the right tail
outlier.percent <- apply(x.4[, -13], 2, whisker) * 100
names(outlier.percent) <- names4[-13]
print(round(outlier.percent, 2))
```

Next, we check whether we can perform some transformation to overcome this.

```{r}
# square root transformation
check <- apply(x.4[, -13], 2, 
               function(x) oc.check(x, method = 'sqrt'))
names(check) <- names4[-13]
print(round(check * 100, 2))
# log transformation
check <- apply(x.4[, -13], 2, 
               function(x) oc.check(x, method = 'log'))
names(check) <- names4[-13]
print(round(check * 100, 2))
```

We observe that

1.  log transformation works better for % Developed, Waterbody Buffer, and % Impervious.
2.  square root transformation works better for % Wetlands, and % Average buffer width.

However, both transformations do not work for % Emergent Herbaceous Wetlands. We try another transformation $x^{0.20}$, which turns out to work.

```{r}
oc.check(x.4[, 4], method = 'power', degree = 0.2) * 100
```

Next, we visualize the spatial distribution of those variables below.

```{r}
ggplot(data = data) + geom_sf(aes(color = x.4[, 1])) + 
  theme_bw() + labs(title = names4[1]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.4[, 2])) + 
  theme_bw() + labs(title = names4[2]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.4[, 3] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names4[3], 
                                   ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = (x.4[, 4]) ^ (0.2))) + 
  theme_bw() + labs(title = paste0(names4[4], 
                                   ' (x ^ (0.2))')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.4[, 5])) + 
  theme_bw() + labs(title = names4[5]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.4[, 6])) + 
  theme_bw() + labs(title = names4[6]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.4[, 7] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names4[7], 
                                   ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.4[, 8] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names4[8], ' (log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.4[, 9])) + 
  theme_bw() + labs(title = names4[9]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.4[, 10]))) + 
  theme_bw() + labs(title = paste0(names4[10], 
                                   ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.4[, 11]))) + 
  theme_bw() + labs(title = paste0(names4[11], 
                                   ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.4[, 12]))) + 
  theme_bw() + labs(title = paste0(names4[12], 
                                   ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
# Land use
ggplot(data = data) +
  geom_sf(aes(color = as.factor(landuse), fill = as.factor(landuse)), size = 0.5) +
  theme_bw() +
  labs(title = names4[13], fill = paste0(names4[13], ' Categories'),
       color = paste0(names4[13], ' Categories')) +
  theme(panel.grid = element_blank())

ggplot(data = data) + geom_sf(aes(color = x.4[, 14])) + 
  theme_bw() + labs(title = paste0(names4[14])) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')


x4.trans <- data.frame(x.4[, 1], x.4[, 2],
                       log(x.4[, 3] + 1e-4), (x.4[, 4]) ^ (0.2),
                       x.4[, 5], x.4[, 6],
                       log(x.4[, 7] + 1e-4),
                       log(x.4[, 8] + 1e-4), x.4[, 9], x.4[, 10],
                       sqrt(x.4[, 11]), sqrt(x.4[, 12]), x.4[, 14])

data[, index.4] <- x4.trans
```

### **2.5 Soil properties**

For this group variable, we only have Available Water Storage of the top 25 cm and Average available Water Capacity. The summary statistics of those variables are presented below. We do not observe many missing values here.

```{r}
# summary
names5 <- c('% Clay', '% Sand', '% Silt',
            'Available Water Storage of the top 25 cm', 
            'Average available Water Capacity',
            'Bulk Density', 'Cation Exchange Capacity',
            'Drainage Class', 'Electroconductivity',
            'Hydrologic Group', 'K factor', 
            'Permeability', 'pH', 'Sodium Absorption Ratio',
            'Soil depth', 'Soil loss tolerance factor',
            'Soil Organic Matter', 'Soil Temp Regieme',
            'Wind Erodability Group')

data$hydgrp_int <- round(data$hydgrp_int)
data$str_int <- round(data$str_int)
data$drainage_class_int <- round(data$drainage_class_int)
data$weg_int <- round(data$weg_int)
x.5 <- data.frame(data$clay, data$sand, data$silt, 
             data$AWS25, data$AWCmean, data$db,
             data$cec, data$drainage_class_int, data$ec,
             data$hydgrp_int, data$kfact, data$weighted_perm,
             data$pH, data$sar, data$soil_depth,
             data$weighted_tfact, data$om_kg_sq_m, data$str_int,
             data$weg_int)

## record indices (useful for later transformation)
colnames(x.5) <- substr(colnames(x.5), 6, nchar(colnames(x.5)))
index.5 <- sapply(colnames(x.5), function(x) which(x == colnames(data)))

summ(x = x.5, names = names5)
```

The histograms of those variables are presented below. Note that their distributions look similar and are slightly right-skewed.

```{r}
cols <- c('magenta', 'deepskyblue', 'indianred1', 
          'slateblue', 'royalblue', 'khaki',
          'salmon', 'paleturquoise2', 'palevioletred1',
          'coral1', 'aquamarine', 'rosybrown1')
par(mfrow = c(3, 3))
for (i in 1:2) {
  for (j in 1:9) {
  hist(x.5[, (i - 1) * 9  + j], border = cols[j], 
       col = 'white',
     main = names5[(i - 1) * 9 + j], xlab = '')
    }
}
par(mfrow = c(1, 1))
hist(x.5[, 19], border = cols[1], 
       col = 'white', main = names5[19], xlab = '')
```

Note that Electroconductivity and Sodium Absorption Ratio are zero-inflated and heavily right-skewed. It may be better to transform them into a binary variable.

```{r}
# Electroconductivity
quantile(data$ec, c(.75, .8, .85, .9, .95, .99), na.rm = TRUE)
table(ifelse(data$ec > 0, 1, 0))

data$ec <- ifelse(data$ec > 0, 1, 0)

# Sodium Absorption Ratio
quantile(data$sar, c(.75, .8, .85, .9, .95, .99), na.rm = TRUE)
table(ifelse(data$sar > 0, 1, 0))

data$sar <- ifelse(data$sar > 0, 1, 0)
```

Their boxplots are presented below. Notice that they have many outliers on the both left and right tails.

```{r}
index.tp <- setdiff(1:19, c(9, 14))
par(mfrow = c(3, 3))
for (i in index.tp) {
  boxplot(x.5[, i], border = i, 
       col = 'white', main = names5[i], xlab = '')
}
```

Next, we check the percentage of outliers below. Both of them have many outliers.

```{r}
# check outlier proportion
pu <- c()
for (j in index.tp) {
  pu <- c(pu, whisker(x.5[, j]))
}
names(pu) <- names5[index.tp]
print(round(pu * 100, 2))

# check outlier proportion
index.transform <- index.tp[which(pu * 100 > 2.1)]
# check square root and log transformation
check.log <- apply(x.5[, index.transform], 2, 
      function(x) oc.check(x, method = 'log')) * 100
names(check.log) <- names(index.transform)

# which works using log
check.log <- round(check.log, 2)
work.log <- index.transform[which(check.log <= 2.1)]

# sticking to log transformation is fine
check.sqrt <- apply(x.5[, index.transform], 2, 
      function(x) oc.check(x, method = 'sqrt')) * 100
# hydrologic group needs log transformation
which(check.sqrt <= 2.1 & check.log > check.sqrt)

# which needs further work
which(check.log > 2.1)
index.fw <- index.transform[which(check.log > 2.1)]
```

We don't find many outliers for % Clay, % Sand, Drainage Class, Soil Temp Regieme, Wind Erodability Group. Note that log transformation works for Permeability. For the remaining variables, we check apply top coding or bottom coding. As we can see from the previous boxplots, we apply

1.  bottom coding to Soil loss tolerance factor.
2.  top coding to % Silt, Cation Exchange Capacity, and Soil Organic Matter
3.  both top coding and bottom coding to other variables in the pool that needs further treatment. And we check the histograms of the variables that receive the above treatment.

And we check the histograms of those transformed variables below.

```{r}
x5.trans <- x.5
x5.trans[, c(9, 14)] <- apply(x5.trans[, c(9, 14)], 2, 
                              function(x) ifelse(x > 0, 1, 0))
# square root transformation
x5.trans[, which(check.sqrt <= 2.1 & check.log > check.sqrt)] <- 
  sqrt(x5.trans[, which(check.sqrt <= 2.1 & check.log > check.sqrt)])

# bottom coding
x5.trans[, 16] <- coding(log(x5.trans[, 16] + 1e-4), tail = 'left')
# top coding
x5.trans[, c(3, 7, 17)] <- apply(x5.trans[, c(3, 7, 17)], 2, 
                                 function(x) coding(log(x + 1e-4), tail = 'right'))
# both top coding and bottom coding
x5.trans[, setdiff(index.fw, c(3, 7, 16, 17))] <- apply(x5.trans[, setdiff(index.fw, c(3, 7, 16, 17))], 2, function(x) coding(x, tail = 'both'))

par(mfrow = c(3, 3))
for (j in index.fw) {
  hist(x5.trans[, j], 
       main = names5[j],
       xlab = '',
       col = 'white', border = j)
}
```

Next, we visualize the spatial distribution of those two variables below.

```{r}
for (j in 1:19) {
  if (j %in% c(9, 14)) {
    ggplot(data = data) + geom_sf(aes(color = as.factor(x5.trans[, j]), 
              fill = as.factor(x5.trans[, j])), size = 0.5) +
  theme_bw() +
  labs(title = names5[j], fill = paste0(names5[j]),
       color = paste0(names5[j])) +
  theme(panel.grid = element_blank())
  } else {
    p <- ggplot(data = data) +
    geom_sf(aes(color = x5.trans[, j])) +
    theme_bw() +
    labs(title = names5[j]) +
    theme(panel.grid = element_blank()) +
    scale_color_gradient(low = "deepskyblue", high = "magenta", 
                         name = '', na.value = 'grey')
  }
  print(p)
}

data[, index.5] <- x5.trans
x5.trans <- x5.trans[, -c(9, 14)]
```

### **2.6 Redox**

We check the summary statistics of the variables in Redox below.

```{r}
# summary
names6 <- c('Mn >= 50 microgram/L', 'Probability of oxic conditions')
x.6 <- cbind(data$redox_Mn, data$oxic)

## record indices (useful for later transformation)
colnames(x.6) <- substr(colnames(x.6), 6, nchar(colnames(x.6)))
index.6 <- sapply(colnames(x.6), function(x) which(x == colnames(data)))

summ(x = x.6, names = names6)
```

Their histogram and boxplot are presented below. "Mn \>= 50 microgram/L" is slightly left-skewed whereas "Probability of oxic conditions" is bell-shaped.

```{r}
par(mfrow = c(1, 2))
hist(data$redox_Mn, col = 'white', border = 'magenta',
     main = names6[1], xlab = '')
hist(data$oxic, col = 'white', border = 'deepskyblue',
     main = names6[2], xlab = '')
par(mfrow = c(1, 2))
boxplot(data$redox_Mn, col = 'white', border = 'magenta',
        main = names6[1])
boxplot(data$oxic, col = 'white', border = 'deepskyblue',
        main = names6[2])
```

Next, we check the proportion of outliers below. As we can observe, we do not find any outliers.

```{r}
# Mn >= 50 microgram/L
whisker(x.6[, 1])
# Probability of oxic conditions
whisker(x.6[, 2])

x6.trans <- x.6
```

Next, we check their spatial distribution below.

```{r}
ggplot(data = data) + geom_sf(aes(color = x6.trans[, 1])) + 
  theme_bw() + labs(title = paste0(names6[1])) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')

ggplot(data = data) + geom_sf(aes(color = x6.trans[, 2])) + 
  theme_bw() + labs(title = paste0(names6[2])) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
```

And we end up with dropping those two variables.

### **2.7 Soil geochemistry**

We check the summary statistics of the variables in soil properties below.

```{r}
# summary
names7 <- c('Antimony', 'Arsenic', 'Beryllium',
            'Cardmium', 'Calcite', 'Calcium',
            'Chromium', 'Hornblende', 'Inorganic C',
            'Iron', 'Kaolinite', 'Lead',
            'Lithium', 'Manganese', 'Magnesium',
            'Mercury', 'Molybdenum', 'Organic C',
            'Phosphorous', 'Potassium', 'Rubidium',
            'Sodium', 'Strontium', 'Titanium',
            'Total 10 A Clay', 'Total 14 A Clay', 'Total C',
            'Total clay', 'Total Plaggen', 'Total Potassium Feldspar',
            'Uranium', 'Vanadium')
x.7 <- data.frame(data$A_Sb, data$A_As, data$A_Be,
             data$A_Cd, data$A_Calcite, data$A_Ca,
             data$A_Cr, data$A_Hornbl, data$A_C_Inorg,
             data$A_Fe, data$A_Kaolinit, data$A_Pb,
             data$A_Li, data$A_Mn, data$A_Mg, 
             data$A_Hg, data$A_Mo, data$A_C_Org, 
             data$A_P, data$A_K, data$A_Rb, 
             data$A_Na, data$A_Sr, data$A_Ti, 
             data$A_Tot_10A, data$A_Tot_14A, data$A_C_Tot, 
             data$A_Tot_Clay, data$A_Tot_Plag, data$A_Tot_K_fs, 
             data$A_U, data$A_V)

## record indices (useful for later transformation)
colnames(x.7) <- substr(colnames(x.7), 6, nchar(colnames(x.7)))
index.7 <- sapply(colnames(x.7), function(x) which(x == colnames(data)))

summ(x = x.7, names = names7)
```

Next, we check their histograms as below. Since there are a lot of variables in this group, we just present the graphs below.

```{r}
cols <- c('magenta', 'deepskyblue', 'indianred1', 
          'slateblue', 'royalblue', 'khaki',
          'salmon', 'paleturquoise2', 'palevioletred1',
          'coral1', 'aquamarine', 'rosybrown1')
par(mfrow = c(3, 3))
for (i in 1:3) {
  for (j in 1:9) {
  hist(x.7[, (i - 1) * 3 + j], border = cols[j], 
       col = 'white',
     main = names7[(i - 1) * 3 + j], xlab = '')
    }
}
par(mfrow = c(2, 3))
for (j in 28:32) {
  hist(x.7[, j], border = cols[j - 27], col = 'white',
     main = names7[j], xlab = '')
}
```

Their boxplots are presented below. Notice that there are many variables with outliers, mostly on the right tail.

```{r}
par(mfrow = c(3, 3))
for (i in 1:3) {
  for (j in 1:9) {
  boxplot(x.7[, (i - 1) * 3 + j], border = cols[j], 
       col = 'white',
     main = names7[(i - 1) * 3 + j], xlab = '')
    }
}
par(mfrow = c(2, 3))
for (j in 28:32) {
  boxplot(x.7[, j], border = cols[j - 27], col = 'white',
     main = names7[j], xlab = '')
}
```

Next, we check the proportion of outliers below.

```{r}
# check outlier proportion
pu <- c()
for (j in 1:32) {
  pu[j] <- whisker(x.7[, j])
}
names(pu) <- names7
print(round(pu * 100, 2))

# check outlier proportion
index.transform <- which(pu * 100 > 2.1)
# check square root and log transformation
check.log <- apply(x.7[, index.transform], 2, 
      function(x) oc.check(x, method = 'log')) * 100
names(check.log) <- names(index.transform)

# which works using log
check.log <- round(check.log, 2)
work.log <- index.transform[which(check.log <= 2.1)]

# sticking to log transformation is fine
check.sqrt <- apply(x.7[, index.transform], 2, 
      function(x) oc.check(x, method = 'sqrt')) * 100
which(check.sqrt <= 2.1 & check.log > check.sqrt)

# which needs further work
which(check.log > 2.1)
index.fw <- index.transform[which(check.log > 2.1)]
```

We don't find many outliers for Hornblende, Inorganic C, Iron, Manganese, Organic C, Potassium, Rubidium, Total C, and Total clay. Note that log transformation works for Beryllium, Cardmium, Magnesium, Phosphorous, and Vanadium. For the remaining variables, we check apply top coding or bottom coding. As we can see from the previous boxplots, we apply

1.  top coding to Calcium, Lithium, Molybdenum, Sodium, Strontium, Chromium, Total 10 A Clay, Total Plaggen, Total Potassium Feldspar, and Total 14 A Clay
2.  both top coding and bottom coding to other variables in the pool that needs further treatment.

And we check the histograms of the variables that receive the above treatment.

```{r}
x7.trans <- x.7
# log transformation
x7.trans[, work.log] <- apply(x7.trans[, work.log], 2, function(x) log(x + 1e-4))
# top coding
x7.trans[, c(6, 7, 13, 17, 22, 23, 25, 26, 29, 30)] <- 
  apply(x7.trans[, c(6, 7, 13, 17, 22, 23, 25, 26, 29, 30)], 
        2, function(x) coding(log(x + 1e-4), tail = 'right'))
# both top coding and bottom coding
x7.trans[, setdiff(index.fw, c(6, 7, 13, 17, 22, 23, 25, 26, 29, 30))] <- apply(x7.trans[, setdiff(index.fw, c(6, 7, 13, 17, 22, 23, 25, 26, 29, 30))], 2, function(x) coding(x, tail = 'both'))

data[, index.7] <- x7.trans

par(mfrow = c(3, 3))
for (j in index.fw) {
  hist(x7.trans[, j], 
       main = names7[j],
       xlab = '',
       col = 'white', border = j)
}
```

Next, we check the spatial distribution of those variables.

```{r}
for (j in 1:32) {
  p <- ggplot(data = data) +
    geom_sf(aes(color = x7.trans[, j])) +
    theme_bw() +
    labs(title = names7[j]) +
    theme(panel.grid = element_blank()) +
    scale_color_gradient(low = "deepskyblue", high = "magenta", 
                         name = '', na.value = 'grey')
  print(p)
}
```

### **2.8 Domestic Well Use**

First, we check its summary statistics below. It appears that it is a categorical variable.

```{r}
# summary
names8 <- c('Estimated rate of domestic well use')
x.8 <- data.frame(data$Pct_Wells)

summ(x = x.8, names = names8)
table(data$Pct_Wells)
```

Next, we visualize its spatial distribution as below.

```{r}
ggplot(data = data) +
  geom_sf(aes(color = as.factor(Pct_Wells), 
              fill = as.factor(Pct_Wells)), size = 0.5) +
  theme_bw() +
  labs(title = names8, fill = names8,
       color = names8) +
  theme(panel.grid = element_blank())
```

## **3. Multicollinearity (Overall)**

In this section, we check multicollinearity of all the variables. As we can see, we do not observe any multicollinearity problems here.

```{r}
x.trans <- cbind(x1.trans, x2.trans, 
                 x3.trans, x4.trans, 
                 x5.trans, x6.trans, x7.trans)
vifs <- c()
for (j in 1:ncol(x.trans)) {
  y.j <- unlist(x.trans[, j])
  x.j <- x.trans[, -j]
  y.j[which(y.j == Inf)] <- NA
  mod <- lm(y.j ~ ., data = as.data.frame(x.j))
  vifs[j] <- 1 / (1 - summary(mod)$r.squared)
}
names(vifs) <- colnames(x.trans) <- c(names1, names2[4], names3, 
                                      names4[-13], names5[-c(9, 14)], names6, 
                                      names7)
print(round(vifs, 2))
```

As we can observe, there exist serious multicollinearity among those transformed variables. Next, we try to get a set of variables with VIFs smaller than 10.

```{r}
keep <- c('Base-flow Index', 'Depth to Water', 'Mn >= 50 microgram/L', 'Temperature')
vifs0 <- vifs
pool <- 1:length(vifs)
nn <- c()
while (max(na.omit(vifs0)) > 10) {
  vifs0 <- c()
  pool <- 1:ncol(x.trans)
  for (j in pool) {
    y.j <- unlist(x.trans[, j])
    x.j <- x.trans[, -j]
    y.j[which(y.j == Inf)] <- NA
    mod <- lm(y.j ~ ., data = as.data.frame(x.j))
    vifs0[j] <- 1 / (1 - summary(mod)$r.squared)
  }
  if (max(na.omit(vifs0)) > 10) {
    if (colnames(x.trans)[which.max(vifs0)] %in% keep) {
      nn <- c(nn, colnames(x.trans)[which(order(vifs0) == 2)])
    } else {
      nn <- c(nn, colnames(x.trans)[which.max(vifs0)])
    }
    x.trans <- x.trans[, - which.max(vifs0)]
  }
}
# which variables to remove
print(nn)
print(vifs0)

# index to remove
index <- c(index.4[which(names4 %in% nn)], index.5[which(names5 %in% nn)],
  index.7[which(names7 %in% nn)])
# remove HUC_12, drainage, redox and oxic
index <- c(index, c(3, 22, 54, 55, 59))

# final set of variables
data_transform <- data[, - index]

for (j in setdiff(3:64, c(3, 4, 5, 39, 40, 44))) {
  x.j <- data_transform[[j]]
  x.j[is.na(x.j) == TRUE] <- median(x.j, na.rm = TRUE)
  data_transform[[j]] <- x.j
}

st_write(data_transform, "nc_grid_vulnerability_transformed.gpkg", 
         layer = "my_layer", driver = "GPKG", append = FALSE)
```

As we can observe, the above variables mainly come from Soil properties, Soil geochemistry, Landscape. If we remove them, we will not have multicollinearity problems.
