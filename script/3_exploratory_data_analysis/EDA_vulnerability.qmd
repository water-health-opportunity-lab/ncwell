---
title: "Exploratory Data Analysis (Vulnerability Module Part I)"
format: html
toc: true
editor: visual
code-fold: true
self-contained: true
---

## 1. Highlight and a Summary

The below is a highlight for this exploratory data analysis of hazard module.

1.  **There are a lot of missing values for Tile Drainage.**
2.  It is more complicated to deal with the outliers in this dataset. I have tried transformation and top coding to deal with them. However, even after this, there are still some outliers. Nevertheless, they look more well-behaved after such treatment.
3.  There exist serious multicollinearity in this dataset. Under a rule of thumb for VIF to be 10, we have to remove % Agriculture, % Natural Land Cover, % Wetlands, Recharge, and % Forest and Woody Wetlands.

The sample size of this dataset is 129169 and it has 36 variables.

```{r}
# load packages
require('sf')
require('ggplot2')

# read data
data <- st_read('nc_grid_vulnerability_pt1_v2.gpkg')

# total sample size
(n <- nrow(data))

# dimension
(p <- ncol(data) - 3)

# colnames
colnames(data)
```

Next, we look into the variables in different groups.

## 2. Analysis for different variables

Next, we present the exploratory data analysis for different variables. We check missing percentage, mean, standard deviation (SD), median, and interquantile range (IQR) of the variables. Moreover, the histograms and boxplots of the variables are also presented. The proportions of outliers are also provided.

### **2.1 Groundwater**

First, the descriptive statistics of the variables in groundwater group are presented below. We observe a lot of variability for Transmissivity.

```{r}
# check interquantile range
iqr <- function(x) paste0(round(quantile(na.omit(x), .25), 2), '-', 
                          round(quantile(na.omit(x), .75), 2))

# function for summary statistics
summ <- function(x, names) {
  p <- ncol(x)
  n <- nrow(x)
  tab <- data.frame()
  for (j in 1:p) {
    x.j <- x[, j]
    info <- c(round(length(which(is.na(x.j) == TRUE)) / n * 100, 2),
              class(x.j),
              round(mean(x.j, na.rm = TRUE), 2),
              round(sd(x.j, na.rm = TRUE), 2),
              round(median(x.j, na.rm = TRUE), 2),
              iqr(x.j))
    tab <- rbind(tab, info)
  }
  tab <- cbind(names, tab)
  colnames(tab) <- c('Name', 'Missing Percentage', 'Class', 'Mean', 
                     'SD', 'Median', 'IQR')
  print(tab)
}

# summary
names1 <- c('Aquifer Rock Type', 'Depth to Water', 'Nitrate, domestic well depths',
            'Nitrate, public well depths', 'Transmissivity', 'Unsat Zone Travel Time',
            'Unsat Zone Water Content')
x.1 <- cbind(data$aq_rocktype, data$dtw, data$no3_dom, data$no3_pub,
             data$trans, data$unsatTT, data$unsatWC)
summ(x = x.1, names = names1)
```

The histograms of those variables are presented below. Note that

1.  Aquifer Rock Type is a categorical variable.
2.  The distribution of Depth to Water is right-skewed.
3.  The distribution of Nitrate, domestic well depths is right-skewed.
4.  The distribution of Nitrate, public well depths is right-skewed.
5.  The distribution of Transmissivity is heavily right-skewed.
6.  The distribution of Unsat Zone Travel Time is right-skewed.
7.  The distribution of Unsat Zone Water Content is bell-shaped.

```{r}
par(mfrow = c(1, 3))
hist(data$aq_rocktype, col = 'white', border = 'magenta',
     xlab = '',
     main = names1[1])
hist(data$dtw, col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names1[2])
hist(data$no3_dom, col = 'white', border = 'indianred1',
     xlab = '',
     main = names1[3])
par(mfrow = c(1, 3))
hist(data$no3_pub, col = 'white', border = 'magenta',
     xlab = '',
     main = names1[4])
hist(data$trans, col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names1[5])
hist(data$unsatTT, col = 'white', border = 'indianred1',
     xlab = '',
     main = names1[6])
hist(data$unsatWC, col = 'white', border = 'slateblue',
     xlab = '',
     main = names1[7])
```

The boxplots of those variables (except Aquifer Rock Type) are presented below. As we can see, all except for Unsat Zone Water Content contains a lot of outliers.

```{r}
par(mfrow = c(1, 3))
boxplot(data$dtw, col = 'white', border = 'magenta',
        xlab = names1[2])
boxplot(data$no3_dom, 
        xlab = names1[3],
        col = 'white', border = 'deepskyblue')
boxplot(data$no3_pub, 
        xlab = names1[4],
        col = 'white', border = 'indianred1')
par(mfrow = c(1, 3))
boxplot(data$trans, col = 'white', border = 'magenta',
        xlab = names1[5])
boxplot(data$unsatTT, 
        xlab = names1[6],
        col = 'white', border = 'deepskyblue')
boxplot(data$unsatWC, 
        xlab = names1[7],
        col = 'white', border = 'indianred1')
```

In specific, the percentage of outliers on the right-tail is shown below. They are defined as the observations that have distances greater than 1.5 times IQR from the 75% quantile or distances lower than 1.5 times IQR from the 25% quantile. So, we observe there are a lot of outliers for

1.  Nitrate, domestic well depths
2.  Nitrate, public well depths
3.  Transmissivity

```{r}
# find the percentage of outliers on the right tail
whisker <- function(x) {
  n <- length(x)
  qf <- quantile(x, c(.25, .75), na.rm = TRUE)
  IQR <- qf[2] - qf[1]
  length(which(x > qf[2] + 1.5 * IQR | x < qf[1] - 1.5 * IQR)) / n
}

# percentage of outliers on the right tail
outlier.percent <- apply(x.1[, 2:7], 2, whisker) * 100
names(outlier.percent) <- names1[-1]
print(round(outlier.percent, 2))
```

Next, we check if square root transformation helps. The idea is to cover a desired proportion of data (say, 98%) of normally behaved data under some transformation.

```{r}
oc.check <- function(x, level = .99, method = 'power', degree) {
  x[which(x == Inf)] <- NA
  x <- na.omit(x)
  cv <- qnorm(level)
  if (method == 'log') {
    x <- log(na.omit(x) + 1e-4)
  } else if (method == 'sqrt') {
    x <- sqrt(x)
  } else if (method == 'boxcox') {
    fit <- lm(x ~ 1)
    bc <- boxcox(fit, lambda = seq(2, 10, 0.1))
    best_lambda <- bc$x[which.max(bc$y)]
    x <- (x ^ best_lambda - 1) / best_lambda
  } else if (method == 'power') {
    x <- x ^ (degree)
  } else if (method == 'log10') {
    x <- log10(x + 1e-4)
  }
  n <- length(x)
  length(which(x > mean(x) + cv * sd(x) | x < mean(x) - cv * sd(x))) / n
}

# square root transformation
check <- apply(x.1[, 2:7], 2, function(x) oc.check(x, method = 'sqrt'))
names(check) <- names1[-1]
print(round(check * 100, 2))

# log transformation
check <- apply(x.1[, 2:7], 2, function(x) oc.check(x, method = 'log'))
names(check) <- names1[-1]
print(round(check * 100, 2))
```

As we can see,

1.  square root transformation works for Depth to Water, Transmissivity, Unsat Zone Travel Time, and Unsat Zone Water Content.
2.  Log transformation works better than Nitrate, domestic well depths, and Nitrate, public well depths.

Next, we take a look at the spatial distribution of those two variables. For superfund, most of the regions have zero values with a few spots being greater than zero.

```{r}
ggplot(data = data) + geom_sf(aes(color = sqrt(x.1[, 1]))) + 
  theme_bw() + labs(title = paste0(names1[1], ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.1[, 2] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names1[2], ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.1[, 3] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names1[3], ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.1[, 4]))) + 
  theme_bw() + labs(title = paste0(names1[4], ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.1[, 5]))) + 
  theme_bw() + labs(title = paste0(names1[5], ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.1[, 6]))) + 
  theme_bw() + labs(title = paste0(names1[6], ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.1[, 7])) + 
  theme_bw() + labs(title = names1[7]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')

x1.trans <- data.frame(sqrt(x.1[, 1]), log(x.1[, 2] + 1e-4),
                       log(x.1[, 3] + 1e-4), sqrt(x.1[, 4]),
                       sqrt(x.1[, 5]), sqrt(x.1[, 6]), x.1[, 7])
```

### **2.2 Geology**

Note that Bedrock, Lithology, and Surficial geology are categorical. So, we simply summarize the proportion of the categories below. For tile drainage, its summary statistics are provided as well. Note that there are a lot of missing values for tile drainage.

```{r}
## Bedrock
print('Percentage of categories in Bedrock')
round(table(data$KB) / nrow(data) * 100, 2)
print('Missing percentage of Bedrock')
length(which(is.na(data$KB) == TRUE)) * 100 / nrow(data)

## Lithology
print('Percentage of categories in Lithology')
round(table(data$lith) / nrow(data) * 100, 2)
print('Missing percentage of Lithology')
length(which(is.na(data$lith) == TRUE)) * 100 / nrow(data)

## Surficial geology
print('Percentage of categories in Surficial geology')
round(table(data$surfgeo) / nrow(data) * 100, 2)
print('Missing percentage of Surficial geology')
length(which(is.na(data$surfgeo) == TRUE)) * 100 / nrow(data)

# summary
names2 <- c('Bedrock', 'Lithology', 'Surficial geology',
            'Tile Drainage')
x.2 <- data.frame(data$KB, data$lith, data$surfgeo, data$drainage)
summ(x = as.matrix(x.2[, 4]), names = names2[4])
```

Next, we check the histogram and boxplot of tile drainage. As we can observe, Tile Drainage is right-skewed with some outliers on the right tail.

```{r}
par(mfrow = c(1, 2))
hist(data$drainage, col = 'white', border = 'magenta',
     xlab = '',
     main = names2[4])
boxplot(data$drainage, col = 'white', border = 'magenta',
        xlab = names2[4])
```

Next, we find the percentage of outliers on the right-tail. As we can see, we do not observe many outliers. So, there is no need to do transformation.

```{r}
# find the percentage of outliers on the right tail
right.whisker <- function(x) {
  n <- length(x)
  qf <- quantile(x, c(.25, .75), na.rm = TRUE)
  IQR <- qf[2] - qf[1]
  length(which(x > qf[2] + 1.5 * IQR)) / n
}

# percentage of outliers on the right tail
outlier.percent <- right.whisker(data$drainage) * 100 
names(outlier.percent) <- names2[4]
print(round(outlier.percent, 2))
```

Next, we take a look at the spatial distribution of those variables below.

```{r}
# Bedrock
ggplot(data = data) +
  geom_sf(aes(color = KB, fill = KB), size = 0.5) +
  theme_bw() +
  labs(title = names2[1], fill = paste0(names2[1], ' Categories'),
       color = paste0(names2[1], ' Categories')) +
  theme(panel.grid = element_blank())

# Lithology
ggplot(data = data) +
  geom_sf(aes(color = lith, fill = lith), size = 0.5) +
  theme_bw() +
  labs(title = names2[2], fill = paste0(names2[2], ' Categories'),
       color = paste0(names2[2], ' Categories')) +
  theme(panel.grid = element_blank()) + 
  theme(legend.title = element_text(size = 3), 
        legend.text = element_text(size = 3))
# Surficial geology
ggplot(data = data) +
  geom_sf(aes(color = surfgeo, fill = surfgeo), size = 0.5) +
  theme_bw() +
  labs(title = names2[3], fill = paste0(names2[3], ' Categories'),
       color = paste0(names2[3], ' Categories')) +
  theme(panel.grid = element_blank())

ggplot(data = data) + geom_sf(aes(color = drainage)) + 
  theme_bw() + labs(title = "Tile Drainage") + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')

x2.trans <- data$drainage
```

### **2.3 Hydroclimate**

Next, we summarize the variables in the hydroclimate group. Note that the hydrologic unit code is a categorical variable. For the remaining variables, we do not observe many missing values.

```{r}
# distribution of hydrologic unit code
summary(data$HUC_12)

names3 <- c('Base-flow Index', 'Evapotranspiration', 
            'Precipitation', 
            'Quickflow', 'Recharge', 'Stream Density',
            'Temperature', 'Effective Recharge')
x.3 <- data.frame(data$bfi, data$ET, data$ppt, 
                  data$qf, data$rech, data$stm_den, 
                  data$tmean, data$effrech)
summ(x = x.3, names = names3)
```

Next, we check the histogram of those variables.

```{r}
par(mfrow = c(1, 3))
hist(x.3[, 1], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[1])
hist(x.3[, 2], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[2])
hist(x.3[, 3], col = 'white', border = 'indianred1',
     xlab = '',
     main = names3[3])
par(mfrow = c(1, 3))
hist(x.3[, 4], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[4])
hist(x.3[, 5], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[5])
hist(x.3[, 6], col = 'white', border = 'indianred1',
     xlab = '',
     main = names3[6])
par(mfrow = c(1, 2))
hist(x.3[, 7], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[7])
hist(x.3[, 8], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[8])
```

As we can observe,

1.  Base-flow index and Evapotranspiration are bell-shaped.
2.  The distributions of Quickflow, Precipitation, Recharge, and Effective Recharge are right-skewed.
3.  The distribution of Temperature is left-skewed.

Next, we check the boxplots of those variables.

```{r}
par(mfrow = c(1, 3))
boxplot(x.3[, 1], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[1])
boxplot(x.3[, 2], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[2])
boxplot(x.3[, 3], col = 'white', border = 'indianred1',
     xlab = '',
     main = names3[3])
par(mfrow = c(1, 3))
boxplot(x.3[, 4], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[4])
boxplot(x.3[, 5], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[5])
boxplot(x.3[, 6], col = 'white', border = 'indianred1',
     xlab = '',
     main = names3[6])
par(mfrow = c(1, 2))
boxplot(x.3[, 7], col = 'white', border = 'magenta',
     xlab = '',
     main = names3[7])
boxplot(x.3[, 8], col = 'white', border = 'deepskyblue',
     xlab = '',
     main = names3[8])
```

According to the boxplots, we see there exist some outliers for

1.  Evapotranspiration on the both right and left tails.
2.  Precipitation on the both right and left tails.
3.  Quickflow on the right tail
4.  Recharge on the right tail
5.  Stream Density on the both right and left tails.
6.  Temperature on the left tail.
7.  Effective Recharge on the right tail.

Last, we check the proportion of outliers as below. As we can observe below, there are many outliers for Precipitation, Quickflow, Recharge, Stream Density, and Temperature.

```{r}
whisker <- function(x) {
  n <- length(x)
  qf <- quantile(x, c(.25, .75), na.rm = TRUE)
  IQR <- qf[2] - qf[1]
  length(which(x > qf[2] + 1.5 * IQR | x < qf[1] - 1.5 * IQR)) / n
}
# percentage of outliers on the right tail
outlier.percent <- apply(x.3, 2, whisker) * 100
names(outlier.percent) <- names3
print(round(outlier.percent, 2))
```

Similarly, we check whether we can apply some transformation to avoid this issue.

```{r}
check <- apply(x.3, 2, function(x) oc.check(x, method = 'sqrt'))
names(check) <- names3
print(round(check * 100, 2))
check <- apply(x.3, 2, function(x) oc.check(x, method = 'log'))
names(check) <- names3
print(round(check * 100, 2))
```

So, some of those transformations do not help. To resolve this, we try if the top coding helps, which replaces the values above \$1-\\alpha\$ quantile of the variable with \$1-\\alpha\$ quantile and those below \$\\alpha\$ quantile of the variable with \$\\alpha\$ quantile. As we can observe below, it slightly helps with \$\\alpha = 2\\%\$.

```{r}
top.code <- function(x, alpha = 0.02) {
  lt <- quantile(x, alpha, na.rm = TRUE)
  rt <- quantile(x, 1 - alpha, na.rm = TRUE)
  x[which(x < lt)] <- lt
  x[which(x > rt)] <- rt
  return(x)
}
# Evaportranspiration
x3.2.trans <- top.code(x.3[, 2])
oc.check(x3.2.trans, method = 'power', degree = 1) * 100

# precipitation
x3.3.trans <- top.code(sqrt(x.3[, 3]))
oc.check(x3.3.trans, method = 'power', degree = 1) * 100

# quickflow
x3.4.trans <- top.code(log(x.3[, 4] + 1e-4))
oc.check(x3.4.trans, method = 'power', degree = 1) * 100

# recharge
x3.5.trans <- top.code(log(x.3[, 5] + 1e-4))
oc.check(x3.5.trans, method = 'power', degree = 1) * 100

# Stream density
x3.6.trans <- top.code(log(x.3[, 6] + 1e-4))
oc.check(x3.6.trans, method = 'power', degree = 1) * 100

# Temperature
x3.7.trans <- top.code(sqrt(x.3[, 7]))
oc.check(x3.7.trans, method = 'power', degree = 1) * 100
```

So, even after top coding, there are some outliers. It might be better to check their distributions again. As we can observe below, they appear much more well-behaved.

```{r}
x3.trans <- cbind(x.3[, 1], x3.2.trans, x3.3.trans,
                  x3.4.trans, x3.5.trans, x3.6.trans, 
                  x3.7.trans, log(x.3[, 8] + 1e-4))
cols <- c('magenta', 'deepskyblue', 'indianred1',
          'slateblue', 'royalblue', 'salmon')
par(mfrow = c(2, 3))
for (i in 2:7) {
  hist(x3.trans[, i], border = cols[i - 1], 
       col = 'white', main = paste0(names3[i]))
}
```

Next, we take a look at the spatial distribution of the transformed variables.

```{r}
ggplot(data = data) + geom_sf(aes(color = x.3[, 1])) + 
  theme_bw() + labs(title = names3[1]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 2])) + 
  theme_bw() + labs(title = names3[2]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 3])) + 
  theme_bw() + labs(title = paste0(names3[3], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 4])) + 
  theme_bw() + labs(title = paste0(names3[4], ' (Transformed')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 5])) + 
  theme_bw() + labs(title = paste0(names3[5], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 6])) + 
  theme_bw() + labs(title = paste0(names3[6], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 7])) + 
  theme_bw() + labs(title = paste0(names3[7], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x3.trans[, 8])) + 
  theme_bw() + labs(title = paste0(names3[8], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
```

### **2.4 Landscape**

Some of the variables in Landscape group are not included in this dataset, such as Land cover and Slope. The summary statistics of the variables in this group are provided below.

```{r}
# summary
names4 <- c('% Agriculture', '% Croplands', '% Developed',
            '% Emergent Herbaceous Wetlands', '% Forest', '% Forest and Woody Wetlands',
            'Waterbody Buffer', '% Impervious', '% Natural Land Cover', '% Pasture',
            '% Wetlands', 'Average buffer width', 'Land use')
x.4 <- cbind(data$PAGT, data$PAGC, data$PDEV, data$PWETL95,
             data$PFOR, data$PFOR90, data$rfor9045, data$PIMPV,
             data$N_INDEX, data$PAGP, data$PWETL, data$Avg_Buff_Width,
             data$landuse)
summ(x = x.4, names = names4)
```

The histograms of those variables are provided below. Note that

1.  The distribution of % Agriculture is right-skewed.
2.  The distribution of % Croplands is right-skewed.
3.  The distribution of % Developed is right-skewed.
4.  The distribution of % Emergent Herbaceous Wetlands is heavily right-skewed.
5.  The distribution of % Forest is not either left-skewed or right-skewed.
6.  The distribution of Forest and Woody Wetlands look bell-shaped.
7.  The distribution of Waterbody Buffer is left-skewed.
8.  The distribution of % Impervious is heavily right-skewed.
9.  The distribution of % Natural Land Cover looks slightly left-skewed.
10. The distribution of % Pasture is right-skewed.
11. The distribution of % Wetlands is right-skewed.
12. The distribution of Average buffer width is highly right-skewed.
13. The distribution of Land use is categorical.

```{r}
cols <- c('magenta', 'deepskyblue', 'indianred1')
par(mfrow = c(1, 3))
for (j in 1:3) {
  hist(x.4[, j], col = 'white', border = cols[j],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 4:6) {
  hist(x.4[, j], col = 'white', border = cols[j - 3],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 7:9) {
  hist(x.4[, j], col = 'white', border = cols[j - 6],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 10:12) {
  hist(x.4[, j], col = 'white', border = cols[j - 9],
       xlab = '',
       main = names4[j])
}

hist(x.4[, 13], col = 'white', border = cols[1],
     xlab = '', main = names4[13])
```

The boxplots of those variables are summarized below. We can observe there are many outliers for % Developed, % Emergent Herbaceous Wetlands, Waterbody Buffer, % Impervious, and Average buffer width.

```{r}
par(mfrow = c(1, 3))
for (j in 1:3) {
  boxplot(x.4[, j], col = 'white', border = cols[j],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 4:6) {
  boxplot(x.4[, j], col = 'white', border = cols[j - 3],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 7:9) {
  boxplot(x.4[, j], col = 'white', border = cols[j - 6],
       xlab = '',
       main = names4[j])
}

par(mfrow = c(1, 3))
for (j in 10:12) {
  boxplot(x.4[, j], col = 'white', border = cols[j - 9],
       xlab = '',
       main = names4[j])
}
```

Next, we check the percentage of outliers below.

```{r}
# percentage of outliers on the right tail
outlier.percent <- apply(x.4[, -13], 2, whisker) * 100
names(outlier.percent) <- names4[-13]
print(round(outlier.percent, 2))
```

Next, we check whether we can perform some transformation to overcome this.

```{r}
# square root transformation
check <- apply(x.4[, -13], 2, 
               function(x) oc.check(x, method = 'sqrt'))
names(check) <- names4[-13]
print(round(check * 100, 2))
# log transformation
check <- apply(x.4[, -13], 2, 
               function(x) oc.check(x, method = 'log'))
names(check) <- names4[-13]
print(round(check * 100, 2))
```

We observe that

1.  log transformation works better for % Developed, Waterbody Buffer, and % Impervious.
2.  square root transformation works better for % Pasture, % Wetlands, and % Average buffer width.

However, both transformations do not work for % Emergent Herbaceous Wetlands. We try another transformation $x^{0.20}$, which turns out to work.

```{r}
oc.check(x.4[, 4], method = 'power', degree = 0.2) * 100
```

Next, we visualize the spatial distribution of those variables below.

```{r}
ggplot(data = data) + geom_sf(aes(color = x.4[, 1])) + 
  theme_bw() + labs(title = names4[1]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.4[, 2])) + 
  theme_bw() + labs(title = names4[2]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.4[, 3] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names4[3], 
                                   ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = (x.4[, 4]) ^ (0.2))) + 
  theme_bw() + labs(title = paste0(names4[4], 
                                   ' (x ^ (0.2))')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.4[, 5])) + 
  theme_bw() + labs(title = names4[5]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.4[, 6])) + 
  theme_bw() + labs(title = names4[6]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.4[, 7] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names4[7], 
                                   ' (Log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = log(x.4[, 8] + 1e-4))) + 
  theme_bw() + labs(title = paste0(names4[8], ' (log)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x.4[, 9])) + 
  theme_bw() + labs(title = names4[9]) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.4[, 10]))) + 
  theme_bw() + labs(title = paste0(names4[10], 
                                   ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.4[, 11]))) + 
  theme_bw() + labs(title = paste0(names4[11], 
                                   ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = sqrt(x.4[, 12]))) + 
  theme_bw() + labs(title = paste0(names4[12], 
                                   ' (Square root)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
# Land use
ggplot(data = data) +
  geom_sf(aes(color = as.factor(landuse), fill = as.factor(landuse)), size = 0.5) +
  theme_bw() +
  labs(title = names4[13], fill = paste0(names4[13], ' Categories'),
       color = paste0(names4[13], ' Categories')) +
  theme(panel.grid = element_blank())


x4.trans <- data.frame(x.4[, 1], x.4[, 2],
                       log(x.4[, 3] + 1e-4), (x.4[, 4]) ^ (0.2),
                       x.4[, 5], x.4[, 6],
                       log(x.4[, 7] + 1e-4),
                       log(x.4[, 8] + 1e-4), x.4[, 9], sqrt(x.4[, 10]),
                       sqrt(x.4[, 11]), sqrt(x.4[, 12]))
```

### **2.5 Soil properties**

For this group variable, we only have Available Water Storage of the top 25 cm and Average available Water Capacity. The summary statistics of those variables are presented below. We do not observe many missing values here.

```{r}
# summary
names5 <- c('Available Water Storage of the top 25 cm', 
            'Average available Water Capacity')
x.5 <- cbind(data$AWS25, data$AWCmean)
summ(x = x.5, names = names5)
```

The histograms of those variables are presented below. Note that their distributions look similar and are slightly right-skewed.

```{r}
cols <- c('magenta', 'deepskyblue')
par(mfrow = c(1, 2))
for (j in 1:2) {
  hist(x.5[, j], col = 'white', border = cols[j],
       xlab = '',
       main = names5[j])
}
```

Their boxplots are presented below. Notice that they have many outliers on the both left and right tails.

```{r}
par(mfrow = c(1, 2))
for (j in 1:2) {
  boxplot(x.5[, j], col = 'white', border = cols[j],
       xlab = '',
       main = names5[j])
}
```

Next, we check the percentage of outliers below. Both of them have many outliers.

```{r}
# percentage of outliers
outlier.percent <- apply(x.5, 2, whisker) * 100
names(outlier.percent) <- names5
print(round(outlier.percent, 2))
```

Next, we check whether we can do some transformation to resolve this. It appears that both of them do not help. As both of them already look bell-shaped, it may not be a good idea to further transform them. There are two possible considerations. First, just leave the outliers as they are. Second, replace those outliers by 99% percentile if it is greater than 99% quantile and by 1% percentile if it is smaller than 1% quantile.

```{r}
# square root
check <- apply(x.5, 2, function(x) oc.check(x, method = 'sqrt'))
names(check) <- names5
print(round(check * 100, 2))
# log transformation
check <- apply(x.5, 2, function(x) oc.check(x, method = 'log10'))
names(check) <- names5
print(round(check * 100, 2))
```

Next, we try top coding to see if it helps. According to the histograms below, they look more well-behaved.

```{r}
# Available Water Storage of the top 25 cm
x5.1.trans <- top.code(sqrt(x.5[, 1]), alpha = .02)
oc.check(x5.1.trans, method = 'power', degree = 1) * 100

# Average available Water Capacity
x5.2.trans <- top.code(sqrt(x.5[, 2]), alpha = .02)
oc.check(x5.2.trans, method = 'power', degree = 1) * 100

# histograms
x5.trans <- cbind(x5.1.trans, x5.2.trans)
cols <- c('magenta', 'deepskyblue')
par(mfrow = c(1, 2))
for (i in 1:2) {
  hist(x5.trans[, i], border = cols[i], xlab = '',
       col = 'white', main = paste0(names5[i]))
}
```

Next, we visualize the spatial distribution of those two variables below.

```{r}
ggplot(data = data) + geom_sf(aes(color = x5.trans[, 1])) + 
  theme_bw() + labs(title = paste0(names5[1], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
ggplot(data = data) + geom_sf(aes(color = x5.trans[, 2])) + 
  theme_bw() + labs(title = paste0(names5[2], ' (Transformed)')) + 
  theme(panel.grid = element_blank()) +
  scale_color_gradient(low = "deepskyblue", high = "magenta", 
                       name = '',
                       na.value = 'grey')
```

### **2.6 Redox**

In the current data, we only have the variable "Mn \>= 50 microgram/L". We check its summary statistics below.

```{r}
# summary
names6 <- c('Mn >= 50 microgram/L')
x.6 <- cbind(data$redox_Mn)
summ(x = x.6, names = names6)
```

Its histogram and boxplot are presented below. It is slightly left-skewed.

```{r}
par(mfrow = c(1, 2))
hist(data$redox_Mn, col = 'white', border = 'magenta',
     main = names6, xlab = '')
boxplot(data$redox_Mn, col = 'white', border = 'magenta',
        main = names6)
```

Next, we check its proportion of outliers below. As we can observe, we do not find any outliers.

```{r}
whisker(x.6[, 1])
```

## **3. Multicollinearity (Overall)**

In this section, we check multicollinearity of all the variables. As we can see, we do not observe any multicollinearity problems here.

```{r}
x.trans <- cbind(x1.trans, x2.trans, 
                 x3.trans, x4.trans, 
                 x5.trans, x.6)
vifs <- c()
for (j in 1:ncol(x.trans)) {
  y.j <- unlist(x.trans[, j])
  x.j <- x.trans[, -j]
  y.j[which(y.j == Inf)] <- NA
  mod <- lm(y.j ~ ., data = as.data.frame(x.j))
  vifs[j] <- 1 / (1 - summary(mod)$r.squared)
}
names(vifs) <- colnames(x.trans) <- c(names1, names2[4], names3, 
                                      names4[1:12], names5, names6)
print(round(vifs, 2))
```

As we can observe, there exist serious multicollinearity among those transformed variables. Next, we try to get a set of variables with VIFs smaller than 10.

```{r}
vifs0 <- vifs
pool <- 1:length(vifs)
nn <- c()
while (max(na.omit(vifs0)) > 10) {
  vifs0 <- c()
  pool <- 1:ncol(x.trans)
  for (j in pool) {
    y.j <- unlist(x.trans[, j])
    x.j <- x.trans[, -j]
    y.j[which(y.j == Inf)] <- NA
    mod <- lm(y.j ~ ., data = as.data.frame(x.j))
    vifs0[j] <- 1 / (1 - summary(mod)$r.squared)
  }
  nn <- c(nn, colnames(x.trans)[which.max(vifs0)])
  x.trans <- x.trans[, - which.max(vifs0)]
}
# which variables to remove
print(nn)
print(vifs0)
```

If we exclude % Croplands, % Natural Land Cover, % Wetlands, Recharge, Base-flow Index, % Forest and Woody Wetlands, and Depth to Water, we will not have multicollinearity problems.
