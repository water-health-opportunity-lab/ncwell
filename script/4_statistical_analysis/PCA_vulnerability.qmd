---
title: "Principal Component Analysis for Vulnerability Module"
format: html
toc: true
editor: visual
code-fold: true
self-contained: true
---

## Principal Component Analysis for Vulnerability Module

### 1. Load packages and data

First, we load the data below and prepare it for the analysis.

```{r, warning=FALSE}
# load packages
library("MASS")
library("dplyr")
library("factoextra")
library("exactextractr")
library("tigris")
library("ggplot2")
library("plotly")
library("sf")
library("tibble")
library("GGally")
library("cluster")
library("mclust")

# read data
data <- st_read('nc_grid_vulnerability_imputed.gpkg')
data <- data[, -which(colnames(data) == 'HUC_12')]
data_capacity <- st_read('nc_grid_capacity_imputed.gpkg')

# add block information
block <- data_capacity %>%
  st_drop_geometry() %>% select(grid_id, block_group_name)
data <- data %>% left_join(block, by = "grid_id")

# total sample size
(n <- nrow(data))

# dimension
(p <- ncol(data) - 3)

# categorical/numerical variable
cate.index <- which(colnames(data) %in% c("surfgeo", 'Pct_Wells', "lith", "KB", "drainage", "aq_rocktype", "ec", "sar", "weg_int", "hydgrp_int", "drainage_class_int", "landuse", 'landcover'))
for (j in 3:65) {
  if (j %in% cate.index) {
    data[[j]] <- as.factor(data[[j]])
  } else {
    data[[j]] <- as.numeric(data[[j]])
  }
}

# avoid NA
data <- na.omit(data)

### drop the location information for easier modeling
data_no_loc <- st_drop_geometry(data)
data_no_loc <- data_no_loc[, -c(1:2, 66)]

### 
model.mat <- model.matrix(~ surfgeo + KB + lith + hydgrp_int + 
                            aq_rocktype + landuse + Pct_Wells + landcover, 
                          data = data_no_loc)
data_no_loc <- cbind(data_no_loc[, -(cate.index - 2)], 
                     model.mat)

### Scale the data
scaled_data <- scale(data_no_loc)
scaled_data <- scaled_data[, which(is.na(apply(scaled_data, 2, sd)) == FALSE)]
```

### 2. PCA and Index Construction

Next, we perform the PCA and check the proportion of variance explained by different PCs. As we can observe below, the first five PCs explained around 45.9% of the variance of the data.

```{r}
### principal component analysis (PCA)
pca <- prcomp(scaled_data, center = FALSE, scale. = FALSE)

##################################### Scree plot
fviz_eig(pca, addlabels = TRUE, barfill = "white", barcolor = "magenta") +
  labs(title = "Scree Plot for Principal Component Analysis", 
       x = "Principal Components", y = "Percentage of Variance Explained") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
```

To make the PCs more interpretable, we apply a varimax rotation to the loadings. Next, we adjust the signs of the loadings by the directionality. Next, we interpret the first five PCs, where the variables received more than weights more than 0.30 are highlighted. For interpretability, the weights for the categorical variables are not included.

```{r, message=FALSE}
p <- ncol(scaled_data)
rot <- varimax(pca$rotation)$rotmat

# correct for directionality
dict <- readxl::read_excel('Independent variables for risk prediction model.xlsx')
directionality <- rep(NA, p)
for (i in 1:p) {
  if (colnames(scaled_data)[i] %in% dict$`Feature Names (internal)`) {
    direct.p <- dict$`Relationship with well contamination risk`[which(colnames(scaled_data)[i] == dict$`Feature Names (internal)`)]
    if (is.na(direct.p) == TRUE) {
      directionality[i] <- NA
    } else if (direct.p == 'decrease') {
      directionality[i] <- -1
    } else if (direct.p == 'increase') {
      directionality[i] <- 1
    } else {
      directionality[i] <- NA
    }
  }
}


for (j in 1:p) {
  if (is.na(directionality[j]) == TRUE) {
    rot[j, which(rot[j, ] > 0)] <- rot[j, which(rot[j, ] > 0)]
  } else if (directionality[j] == 1) {
    rot[j, which(rot[j, ] < 0)] <- -rot[j, which(rot[j, ] < 0)]
  } else if (directionality[j] == -1) {
    rot[j, which(rot[j, ] > 0)] <- -rot[j, which(rot[j, ] > 0)]
  } 
}

rownames(rot) <- colnames(scaled_data)
PCs <- scaled_data %*% rot

## interpretation of the first 5 PCs
# PC1
w1 <- round(rot[, 1], 2)
w1[intersect(which(abs(w1) >= 0.2), 1:52)]

# PC2
w2 <- round(rot[, 2], 2)
w2[intersect(which(abs(w2) > 0.2), 1:52)]

# PC3
w3 <- round(rot[, 3], 2)
w3[intersect(which(abs(w3) > 0.2), 1:52)]

# PC4
w4 <- round(rot[, 4], 2)
w4[intersect(which(abs(w4) > 0.2), 1:52)]

# PC5
w5 <- round(rot[, 5], 2)
w5[intersect(which(abs(w5) > 0.2), 1:52)]
```

In summary, higher values of

1.  PC1 indicate the regions has more lead.
2.  PC2 indicate water moves through the aquifer more easily (high transmissivity) while the topsoil has fewer fine clays and less feldspar/plagioclase material.
3.  PC3 indicate faster pathways plus mineral-rich soils, so contaminants or naturally occurring metals can move into private wells more easily.
4.  PC4 indicate that the near-surface zone is wetter and the topsoil has more cadmium, while thereâ€™s less hornblende.
5.  PC5 indicate that places with higher groundwater nitrate and lower organic carbon in the topsoil. Low organic carbon means less natural filtering/denitrification, so nitrate can leach downward more easily.

To interpret this PC, let us visualize the content of the first two PCs in terms of their contribution. For variable $j$ and PC $k$, the contribution of variable $j$ is defined as

$$
\mathrm{Contribution}_{jk} = \frac{l_{jk}^2}{\sum_{j=1}^p l_{jk}^2}
$$

where $l_{jk}$ is the loading of variable $j$ on PC $k$. So, the contribution of variable $j$ to the first $m$ PCs is defined as

$$
\mathrm{Contribution}_{j} = \sum_{k=1}^m \mathrm{Contribution}_{jk}
$$

The variables with high contribution are shown below.

```{r}
# Compute squared loadings
loadings <- pca$rotation
squared_loadings <- loadings^2

# Compute percentage contribution
contrib <- sweep(squared_loadings, 2, 
                 colSums(squared_loadings), FUN = "/")

# View contribution
cont <- round(apply(contrib[, 1:5], 1, sum), 2) * 100
cont[intersect(which(cont > 10), 1:53)]
```

```{r}
idx <- order(cont, decreasing = TRUE)[1:10]
var_names <- names(cont)[idx]
var_names <- c('Uranium, A horizon', 'Landuse: Developed', 
               'Impervious land (%)', 'Titanium, A horizon', 'Landuse: Cultivated', 
               'Soil eroability factor',
               'Recharge', 'Forest and woody wetlands (%)',
               'Soil bulk density', 'Precipitation')
var_names[which(directionality[idx] == -1)] <- paste0(var_names[which(directionality[idx] == -1)], ' *')
cont.subset <- cont[idx]
print(range(cont))
print(mean(cont))

# Create a data frame for plotting
df <- data.frame(Variable = var_names, cont.subset = cont.subset)

p <- ggplot(df, aes(x = reorder(Variable, cont.subset), y = cont.subset, fill = cont.subset)) +
  geom_bar(stat = "identity", width = 0.6) +   # Thinner bars
  scale_fill_gradient2(low = "white", high = "navy",
                       midpoint = 0, name = "Contribution") +
  coord_flip() +
  labs(title = "Contribution in the physical vulnerability module",
       x = "Variable",
       y = "Contribution") +
  theme_minimal(base_size = 14) + 
  theme(
    axis.text.y  = element_text(color = "black", size = 16, face = "bold"),  # Larger variable labels
    axis.text.x  = element_text(color = "black", size = 16),
    axis.title.x = element_text(color = "black", face = "bold", size = 16),  # Larger axis titles
    axis.title.y = element_text(color = "black", face = "bold", size = 16),
    plot.title   = element_text(color = "black",
                                face  = "bold",
                                hjust = 0.5,
                                size  = 20)  # Larger plot title
  )

ggsave(filename = "vulnerability_import.png",
       plot = p,
       width = 3000, height = 1400, units = "px",
       dpi = 300, device = ragg::agg_png)
```

Next, we consider using weighted average of the PCs, where the weights can be determined based on expert opinions. Let us tentatively use positive equal weights for those 5 PCs. To make the index more interpretable, we consider a transformation guided by Box-Cox transformation. Finally, we standardize the index.

```{r}
## raw distribution of the index
index <- apply(PCs[, 1:5], 1, mean)
hist(index, main = 'Raw Vulnerability Index', col = 'white',
     border = 'magenta')

## transformation
lmod <- lm(index - min(index) + 1e-4 ~ 1)
bc <- boxcox(lmod)
(lambda <- bc$x[which.max(bc$y)])

## standardization
index <- (index - min(index)) / (max(index) - min(index))
index <- index ^ (as.numeric(lambda))
data$index <- index
colnames(data)[1] <- 'ID'
st_write(data[, c(1, 2, 67, 68)], 'index_vulnerability.gpkg',
         layer = "my_layer", driver = "GPKG", append = FALSE)
```

It may be helpful to check the distribution of the index. Its histogram and boxplot are provided below.

```{r}
par(mfrow = c(1, 2))
hist(index, col = 'white', border = 'magenta',
     xlab = '',
     main = 'Index for Vulnerability Module')
boxplot(index, col = 'white', 
        border = 'magenta', xlab = '',
        main = 'Index for Vulnerability Module')
```

### 3. Visualization and Validation of the Index

Next, we perform clustering to validate the index. PCA is a linear mapping of the data. However, clustering can reveal non-linear structures of the data. So, it can serve as a validation method to check if the non-linear structure really meets our real-life expectation.

For simplicity, let us start with $K$-means clustering. First, we determine the number of clusters by assuming that the index follows a mixture of several normal distributions, each representing a distinct group. Under this assumption, model-based criteria such as the Bayesian Information Criterion (BIC) can be used to select the optimal number of clusters. This approach is preferred here because alternative model-free methods are computationally intensive and less feasible for large spatial datasets.

```{r}
set.seed(666)
mod <- Mclust(index)
summary(mod)  # Includes BIC-based optimal number of clusters
```

According to the results above, we shall set $K = 3$. But to be consistent with other modules, let us set $K=9$. To interpret the clustering results, we visualize the spatial distribution of the clusters below in some western counties in NC state, e.g., Henderson County, Buncombe County, and Watauga County. To aid comparison with the index, the clusters are ordered according to their mean index values. For reference, the numerical index is also plotted.

```{r}
# K-means with 6 clusters
mod.kmeans <- kmeans(index, centers = 9)
data$cluster_raw <- mod.kmeans$cluster

# Mean index
mean_index_by_cluster <- tapply(index, mod.kmeans$cluster, mean)

# Order the clusters
ordered_cluster_ids <- order(mean_index_by_cluster) 
cluster_map <- setNames(seq_along(ordered_cluster_ids), ordered_cluster_ids)  # e.g., 3 -> 1, 5 -> 2, ...
data$cluster <- cluster_map[as.character(data$cluster_raw)] 
data$cluster <- as.factor(data$cluster)

# plot
data$cluster <- as.numeric(as.character(data$cluster))

######## Validation plot
custom_colors <- c(
  "1" = "darkblue",
  "2" = "royalblue",
  "3" = "deepskyblue",
  "4" = "paleturquoise1",
  "5" = "palegreen",
  "6" = "rosybrown1",
  "7" = "palevioletred1",
  "8" = "indianred1",
  "9" = "darkred"
)

library(leaflet)

# transform the coordinates into longitude and latitude
data_lonlat <- st_transform(data, crs = 4326)

# Define palettes
pal_cluster <- colorFactor(
  palette = custom_colors,
  domain = data$cluster
)

pal_index <- colorNumeric(
  palette = c("deepskyblue", "magenta"),
  domain = data$index,
  na.color = "grey"
)

# Interactive leaflet map
### subset
data_henderson <- data_lonlat[which(grepl("Henderson County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_henderson, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  
  addControl(
    html = "<strong>Showing: Henderson County</strong>",
    position = "bottomleft"
  )
```

Next, we take a look at the distribution of the clusters and index for the Buncombe County.

```{r}
# Interactive leaflet map
### subset
data_buncombe <- data_lonlat[which(grepl("Buncombe County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_buncombe, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  
  addControl(
    html = "<strong>Showing: Buncombe County</strong>",
    position = "bottomleft"
  )
```

Then, we look at the distribution of the clusters and index for the Watauga County.

```{r}
# Interactive leaflet map
### subset
data_watauga <- data_lonlat[which(grepl("Watauga County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_watauga, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  
  addControl(
    html = "<strong>Showing: Watauga County</strong>",
    position = "bottomleft"
  )
```

As an additional check, we may look at the distribution of the index and the clustering results for Stanly County, which is found to have wells exceeding the Environmental Protection Agency (EPA) arsenic standard. Note that most of the regions have higher cluster means, which are consistent with our expectation.

```{r}
# Interactive leaflet map
### subset
data_stanly <- data_lonlat[which(grepl("Stanly County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_stanly, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) 
```
