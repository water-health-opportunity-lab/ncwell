---
title: "Principal Component Analysis for Capacity Module"
format: html
toc: true
editor: visual
code-fold: true
warning: false 
message: false
self-contained: true
tabset: true
---

## Principal Component Analysis for Capacity Module

### 1. Load packages and data

First, we load the data below and prepare it for the analysis.

```{r warning=FALSE}
# load packages
library("MASS")
library("dplyr")
library("factoextra")
library("exactextractr")
library("tigris")
library("ggplot2")
library("plotly")
library("sf")
library("tibble")
library("GGally")
library("cluster")
library("mclust")

# read data
capacity <- st_read('nc_grid_capacity_imputed.gpkg')
vulnerability <- st_drop_geometry(st_read('nc_grid_vulnerability_imputed.gpkg'))

pct_wells <- vulnerability[, c(2, 44)]
data <- pct_wells %>% 
  left_join(capacity, by = "grid_id") %>%
  filter(Pct_Wells == 100)

# total sample size
(n <- nrow(data))

# dimension
(p <- ncol(data) - 5)

# make sure variables are numeric
for (j in 5:27) {
  data[[j]] <- as.numeric(data[[j]])
}

### drop the location information for easier modeling
data_no_loc <- data[, -(28)] # st_drop_geometry(data)
data_no_loc <- data_no_loc[, -(1:4)]

### drop pct_women, pct_single_parent, pct_under_17, pct_women_gave_birth, pct_us_born, pct_active_commuting, pct_no_move, pct_crowded_housing
data_no_loc <- data_no_loc[, -which(colnames(data_no_loc) %in% c('pct_women', 'pct_single_parent', 'pct_under_17', 'pct_women_gave_birth', 'pct_us_born', 'pct_active_commuting', 'pct_no_move', 'pct_crowded_housing', 'pct_no_computer', 'housing_units_density'))]

### Scale the data
scaled_data <- scale(data_no_loc)
colnames(scaled_data) <- c('Poverty status', 'Health insurance', 'Government jobs',
                           'Minority', 'Lack of English proficiency', 
                           'Unemployment', 'Lack of education', 'Seniors', 
                           'Homeownership rate', 'Plumbing',
                           'Home age', 'No vehicle', 'No Internet')
```

### 2. PCA and Index Construction

Next, we perform the PCA and check the proportion of variance explained by different PCs. As we can observe below, the first three PCs explained the majority of the variance of the data.

```{r}
### principal component analysis (PCA)
pca <- prcomp(scaled_data, center = FALSE, scale. = FALSE)

##################################### Scree plot
fviz_eig(pca, addlabels = TRUE, barfill = "white", barcolor = "magenta") +
  labs(title = "Scree Plot for Principal Component Analysis", 
       x = "Principal Components", y = "Percentage of Variance Explained") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
```

In the literature, the most common way to construct an index using PCA is to use the 1st PC. However, in our case, the 1st PC only explained 14.1% of the variance. So, I would suggest using weighted average of the PCs, where the weights can be determined based on expert opinions.

Before constructing the index, let us first make sure the directionality of the variables is correct. To make the PCs more interpretable, we apply the varimax rotation to the loadings, which maximizes the variance of the loadings within each factor. Next, we interpret the first five PCs, where the variables received more than weights more than 0.30 are highlighted.

```{r}
###### flip the signs

## directionality
directionality <- c(-1, 1, 1, -1, -1, -1, 
                    -1, -1, 1, 1, 1, 
                    -1, -1)

## flip the sign
p <- ncol(scaled_data)
## varimax rotation
rot <- varimax(pca$rotation)$rotmat
rownames(rot) <- colnames(scaled_data)
for (j in 1:p) {
  if (is.na(directionality[j]) == TRUE) {
    rot[j, which(rot[j, ] > 0)] <- rot[j, which(rot[j, ] > 0)]
  } else if (directionality[j] == 1) {
    rot[j, which(rot[j, ] < 0)] <- -rot[j, which(rot[j, ] < 0)]
  } else if (directionality[j] == -1) {
    rot[j, which(rot[j, ] > 0)] <- -rot[j, which(rot[j, ] > 0)]
  } 
}
PCs <- scaled_data %*% rot

## interpretation of the first 5 PCs
# PC1 (increase the capacity) (wealthier, English proficiency, smaller senior population, plumbed homes, own vehicles)
## poverty (-), lack of English (-), seniors (-), plumbing (+), no vehicle (-)
w1 <- round(rot[, 1], 2)
w1[which(abs(w1) > 0.3)]

# PC2 (increase the capacity) (health insured, government employment, English proficiency, college education, smaller senior population, plumbed homes)
## health insurance (+), government jobs (+), lack of English (-), lack of education (-), seniors (-), plumbing (+)
w2 <- round(rot[, 2], 2)
w2[which(abs(w2) > 0.3)]

# PC3 (positive effects on capacity) 
## (health insured, government employment, new home, internet)
## health insurance (+), government jobs (+), home age (+), no internet (-)
w3 <- round(rot[, 3], 2)
w3[which(abs(w3) > 0.3)]

# PC4 (positive effects on capacity) 
## (government employment, smaller minority population, low unemployment, attended college)
## government jobs (+), minority (-), unemployment (-), lack of education (-)
w4 <- round(rot[, 4], 2)
w4[which(abs(w4) > 0.3)]

# PC5 (positive effects on capacity) 
## (English proficiency, owned homes)
## lack of English (-), homeownership rate (+)
w5 <- round(rot[, 5], 2)
w5[which(abs(w5) > 0.3)]
```

We can interpret those PCs in the following way. If a region has higher values of

1.  PC1, it has wealthier individuals with more English proficiency, plumbed homes, vehicle ownership, and a smaller senior population.
2.  PC2, it has more individuals with health insurance, government employment, English proficiency, college education, plumbed homes, and a smaller senior population.
3.  PC3, it has more individuals with health insurance, government employment, new homes, and internet.
4.  PC4, it has more government employment, overall employment, college education, and a smaller minority population.
5.  PC5, it has more individuals with English proficiency and owned homes.

To interpret this PC, let us visualize the content of the first two PCs in terms of their contribution. For variable $j$ and PC $k$, the contribution of variable $j$ is defined as

$$
\mathrm{Contribution}_{jk} = \frac{l_{jk}^2}{\sum_{j=1}^p l_{jk}^2}
$$

where $l_{jk}$ is the loading of variable $j$ on PC $k$. So, the contribution of variable $j$ to the first $m$ PCs is defined as

$$
\mathrm{Contribution}_{j} = \sum_{k=1}^m \mathrm{Contribution}_{jk}
$$

Note that this contribution is irrevant to the directionality of the variables. The following plot presents the correlation between a variable and the PCs, where

1.  the magnitude of contribution is presented in terms of red, where variables with redder color have more contribution.
2.  if the arrows are closer to the PCs, it means the variables are more correlated with the PCs.
3.  both x-axis and y-axis represent the correlation.

```{r}
##################################### Visualize the first two PCs
library(ggplot2)
library(grid)  # for unit()

# Assume rotated_loadings is a matrix from varimax()
df <- as.data.frame(rot[, 1:2])
colnames(df) <- c("PC1", "PC2")
df$varnames <- rownames(df)

# Compute contribution (squared length of vector)
df$contrib <- df$PC1 ^ 2 / sum(df$PC1 ^ 2) + df$PC2 ^ 2 / sum(df$PC2 ^ 2)

# Normalize contribution for scaling (optional)
df$scale <- sqrt(df$contrib / max(df$contrib))  # scale factor for arrow length

# Apply scaling to PC1 and PC2 for proportional arrow length
df$PC1_scaled <- df$PC1 * df$scale
df$PC2_scaled <- df$PC2 * df$scale

# Create unit circle
theta <- seq(0, 2 * pi, length.out = 100)
circle <- data.frame(x = cos(theta), y = sin(theta))

# Plot
ggplot(df, aes(x = 0, y = 0)) +
  geom_path(data = circle, aes(x = x, y = y), inherit.aes = FALSE, color = "gray") +
  geom_segment(aes(xend = PC1_scaled, yend = PC2_scaled, color = contrib),
               arrow = arrow(length = unit(0.2, "cm")),
               size = 2) +
  geom_text(aes(x = PC1_scaled, y = PC2_scaled, label = varnames, color = contrib),
            hjust = 0.5, vjust = -0.8, size = 4, fontface = "bold") +
  scale_color_gradient(low = "white", high = "red") +
  coord_fixed() +
  theme_minimal() +
  labs(title = "PCA Correlation Circle (Varimax Rotated)",
       x = "Rotated PC1", y = "Rotated PC2", color = "Contribution")
```

So, we can observe that plumbing, pregnancy, and housing units are the contributing variables to the index of capacity module in terms of the first two PCs. Next, we visualize the raw distribution of the index, which turns out to be highly left-skewed. To make the index more interpretable, we consider a transformation guided by Box-Cox transformation. Finally, we standardize the index.

```{r}
## raw distribution of the index
index <- apply(PCs, 1, mean)
hist(index, main = 'Raw Capacity Index', col = 'white',
     border = 'magenta')

## transformation
lmod <- lm(index - min(index) + 1e-4 ~ 1)
bc <- boxcox(lmod)
(lambda <- bc$x[which.max(bc$y)])

## standardization
index <- (index - min(index)) / (max(index) - min(index))
index <- index ^ (as.numeric(lambda))
data$index <- index

st_write(data[, c(1, 2, 3, 28)], 'index_capacity.gpkg',
         layer = "my_layer", driver = "GPKG", append = FALSE)
```

To make the results more interpretable, we can compute the contribution of the variables below. Note that Pregnancy, Nativity, Youth, Plumbing, No Computer, and Housing units are the variables with high contribution.

```{r}
# Compute squared loadings
loadings <- rot
squared_loadings <- loadings^2

# Compute percentage contribution
contrib <- sweep(squared_loadings, 2, 
                 colSums(squared_loadings), FUN = "/")

# View contribution
cont <- round(apply(contrib[, 1:5], 1, sum), 2) * 100
print(cont)
cont[which(cont > 30)]
```

It may be helpful to check the distribution of the index. Its histogram and boxplot are provided below.

```{r}
par(mfrow = c(1, 2))
hist(index, col = 'white', border = 'magenta',
     xlab = '',
     main = 'Index for Capacity')
boxplot(index, col = 'white', 
        border = 'magenta', xlab = '',
        main = 'Index for Capacity')
```

### 3. Visualization and Validation of the Index

Next, we perform clustering to validate the index. PCA is a linear mapping of the data. However, clustering can reveal non-linear structures of the data. So, it can serve as a validation method to check if the non-linear structure really meets our real-life expectation.

For simplicity, let us start with $K$-means clustering. First, we determine the number of clusters by assuming that the index follows a mixture of several normal distributions, each representing a distinct group. Under this assumption, model-based criteria such as the Bayesian Information Criterion (BIC) can be used to select the optimal number of clusters. This approach is preferred here because alternative model-free methods are computationally intensive and less feasible for large spatial datasets.

```{r}
mod <- Mclust(index)
summary(mod)  # Includes BIC-based optimal number of clusters
```

According to the results above, we can choose $K = 8$. To interpret the clustering results, we visualize the spatial distribution of the clusters below in some western counties in NC state, e.g., Henderson County, Buncombe County, and Watauga County. To aid comparison with the index, the clusters are ordered according to their mean index values. For reference, the numerical index is also plotted.

```{r}
# K-means with 8 clusters
mod.kmeans <- kmeans(index, centers = 8)
data$cluster_raw <- mod.kmeans$cluster

# Mean index
mean_index_by_cluster <- tapply(index, mod.kmeans$cluster, mean)

# Order the clusters
ordered_cluster_ids <- order(mean_index_by_cluster) 
cluster_map <- setNames(seq_along(ordered_cluster_ids), ordered_cluster_ids)  # e.g., 3 -> 1, 5 -> 2, ...
data$cluster <- cluster_map[as.character(data$cluster_raw)] 
data$cluster <- as.factor(data$cluster)

# plot
data$cluster <- as.numeric(as.character(data$cluster))

######## Validation plot
custom_colors <- c(
  "1" = "darkblue",
  "2" = "royalblue",
  "3" = "deepskyblue",
  "4" = "paleturquoise1",
  "5" = "palegreen",
  "6" = "rosybrown1",
  "7" = "palevioletred1",
  "8" = "indianred1",
  "9" = "darkred"
)

library(leaflet)

# transform the coordinates into longitude and latitude
data <- st_as_sf(data)
data_lonlat <- st_transform(data, crs = 4326)

# Define palettes
pal_cluster <- colorFactor(
  palette = custom_colors,
  domain = data$cluster
)

pal_index <- colorNumeric(
  palette = c("deepskyblue", "magenta"),
  domain = data$index,
  na.color = "grey"
)

# Interactive leaflet map
### subset
data_henderson <- data_lonlat[which(grepl("Henderson County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_henderson, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  
  addControl(
    html = "<strong>Showing: Henderson County</strong>",
    position = "bottomleft"
  )
```

Next, we take a look at the distribution of the clusters and index for the Buncombe County.

```{r}
# Interactive leaflet map
### subset
data_buncombe <- data_lonlat[which(grepl("Buncombe County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_buncombe, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  
  addControl(
    html = "<strong>Showing: Buncombe County</strong>",
    position = "bottomleft"
  )
```

Then, we look at the distribution of the clusters and index for the Watauga County.

```{r}
# Interactive leaflet map
### subset
data_watauga <- data_lonlat[which(grepl("Watauga County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_watauga, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  
  addControl(
    html = "<strong>Showing: Watauga County</strong>",
    position = "bottomleft"
  )
```

According to the kick-off slides, the capacity index is designed to measure a region's ability to mobilize individual and collective resources in response to extreme climate events. In North Carolina, the state capital, Raleigh, and Mecklenburg County (Charlotte metro area, the highest GDP in the state), are expected to have higher capacity than other regions. The distribution of the index in Wake County is shown below.

```{r}
### subset
data_wake <- data_lonlat[which(grepl("Wake County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_wake, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) 
```

The distribution of the index in Mecklenburg County is shown below.

```{r}
### subset
data_mecklenburg <- data_lonlat[which(grepl("Mecklenburg County", data$block_group_name, ignore.case = TRUE) == TRUE), ]

# Interactive leaflet map
leaflet(data_mecklenburg, options = leafletOptions(minZoom = 7)) %>%
  addTiles() %>%
  
  # Cluster layer
  addPolygons(
    fillColor = ~pal_cluster(cluster),
    color = ~pal_cluster(cluster),
    weight = 1,
    fillOpacity = 0.5,
    group = "Cluster",
    popup = ~paste("Cluster:", cluster)
  ) %>%
  
  # Index layer
  addPolygons(
    fillColor = ~pal_index(index),
    color = ~pal_index(index),
    weight = 1,
    fillOpacity = 0.5,
    group = "Index",
    popup = ~paste("Index:", round(index, 2))
  ) %>%
  
  addLegend("bottomright", pal = pal_cluster, values = ~cluster, title = "Cluster", group = "Cluster") %>%
  addLegend("bottomleft", pal = pal_index, values = ~index, title = "Index", group = "Index") %>%
  addLayersControl(
    overlayGroups = c("Cluster", "Index"),
    options = layersControlOptions(collapsed = FALSE)
  ) 
```

This intuition is supported by the maps, where both areas fall into clusters with high mean index values. This alignment serves as a useful cross-check, confirming that the index appropriately reflects regional capacity.
